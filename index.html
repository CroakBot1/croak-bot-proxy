<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Quantum Trading — Live Flowing Chart</title>
<style>
:root{
  --bg1:#041027; --bg2:#071021; --accent:#7afcff; --accent-2:#6de6ff; --card:#0f1b2b; --glass:rgba(255,255,255,0.03);
  --radius:18px; --ease:cubic-bezier(.2,.9,.3,1);
}
html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;color:#e6f7ff;overflow:hidden;}
body{background:linear-gradient(120deg,var(--bg1),var(--bg2));display:flex;align-items:center;justify-content:center;position:relative}

/* --- quantum moving background --- */
#quantum-bg{position:fixed;inset:0;z-index:0;pointer-events:none;background:#041027;}
#quantum-bg canvas{width:100%;height:100%;display:block;}

.bg-blobs{position:fixed;inset:-20%;z-index:0;filter:blur(70px);opacity:.9;pointer-events:none}
#particles{position:fixed;inset:0;z-index:0;pointer-events:none}

.overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:10}
.card{position:relative;z-index:20;width:min(920px,96%);max-width:980px;padding:26px;border-radius:20px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));box-shadow:0 30px 80px rgba(2,8,23,0.7);backdrop-filter:blur(8px);display:grid;grid-template-columns:220px 1fr;gap:20px;align-items:center;overflow:visible}

.logo-wrap{display:flex;flex-direction:column;align-items:center;gap:12px}
.logo{width:140px;height:140px;border-radius:16px;background:linear-gradient(135deg,#072033,#0d2c40);display:flex;align-items:center;justify-content:center;font-weight:800;font-size:34px;color:var(--accent);box-shadow:inset 0 -12px 30px rgba(0,0,0,0.5);transform-style:preserve-3d;animation:logoFloat 4s ease-in-out infinite}
@keyframes logoFloat{0%{transform:translateY(0) rotateX(0) rotateY(0)}50%{transform:translateY(-8px) rotateX(6deg) rotateY(6deg)}100%{transform:translateY(0) rotateX(0) rotateY(0)}}
.orb{position:absolute;width:18px;height:18px;border-radius:50%;background:var(--accent);box-shadow:0 8px 24px rgba(122,252,255,0.15);animation:orbOrbit 3.8s linear infinite}
@keyframes orbOrbit{0%{transform:translate(-120px,-40px)}50%{transform:translate(120px,40px)}100%{transform:translate(-120px,-40px)}}

.content h1{margin:0;font-size:26px;line-height:1.05}
.muted{color:rgba(230,247,255,0.75);margin-top:6px}
.typing{font-weight:700;color:var(--accent);display:inline-block;white-space:nowrap;overflow:hidden;border-right:2px solid rgba(122,252,255,0.5);animation:blinkCaret 1s step-end infinite}
@keyframes blinkCaret{50%{border-color:transparent}}

.ticker{position:relative;overflow:hidden;background:linear-gradient(90deg, rgba(122,252,255,0.03), rgba(122,252,255,0.01));padding:8px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);}
.marquee-inner{display:flex;gap:20px;white-space:nowrap;position:absolute;top:0;left:0;will-change:transform;}
.tick-item{display:inline-flex;gap:10px;align-items:center;padding:0 18px;transition:color 0.3s, text-shadow 0.3s;}
.tick-up{color:#00ffa3;text-shadow:0 0 6px #00ffa3;}
.tick-down{color:#ff4c4c;text-shadow:0 0 6px #ff4c4c;}
.tick-symbol{font-weight:700;color:var(--accent);min-width:60px;}

.chart{width:100%;height:60px;margin-top:14px;overflow:hidden;position:relative}
.chart svg{width:100%;height:100%;position:absolute;top:0;left:0}
.spark path{fill:none;stroke-width:2.5;stroke-linecap:round;stroke-linejoin:round;opacity:0.95;transition:d 0.1s linear}

.actions{display:flex;gap:12px;margin-top:16px}
.btn{padding:10px 16px;border-radius:12px;border:0;cursor:pointer;font-weight:700;background:linear-gradient(90deg,var(--accent),#5ee7ff);color:#041822;box-shadow:0 12px 40px rgba(122,252,255,0.12);transform-origin:center;transition:transform .18s ease}
.btn:hover{transform:translateY(-4px) scale(1.03)}
.ghost{background:transparent;color:#dff7ff;border:1px solid rgba(255,255,255,0.06)}

.bot{display:flex;align-items:center;gap:12px}
.avatar{width:72px;height:72px;border-radius:14px;background:linear-gradient(135deg,#072033,#0b2b3e);display:flex;align-items:center;justify-content:center;font-size:28px;color:var(--accent);box-shadow:0 10px 30px rgba(0,0,0,0.45);animation:avatarBounce 3.2s ease-in-out infinite}
@keyframes avatarBounce{0%{transform:translateY(0)}50%{transform:translateY(-8px)}100%{transform:translateY(0)}}
.wave{width:120px;height:28px;display:block}
.wave svg{width:100%;height:100%}
.wave path{fill:none;stroke:var(--accent);stroke-width:2;stroke-linecap:round;animation:wave 1.6s linear infinite}
@keyframes wave{0%{stroke-dashoffset:0}50%{stroke-dashoffset:18}100%{stroke-dashoffset:36}}

@media (max-width:820px){.card{grid-template-columns:1fr;align-items:center}}
</style>
</head>
<body>

<div id="quantum-bg"><canvas></canvas></div>
<canvas id="particles"></canvas>

<div class="overlay">
  <div class="card">
    <div class="logo-wrap">
      <div class="logo">QT</div>
      <div style="font-size:13px;color:rgba(230,247,255,0.7)">Quantum Trading Bot</div>
      <div class="orb" style="left:42px;top:26px"></div>
    </div>
    <div class="content">
      <h1><span class="typing" id="typing">Adaptive market signals</span></h1>
      <div class="muted">Prepare strategies backed by AI-driven insights — live flowing preview</div>

      <div class="ticker" aria-hidden="true">
        <div class="marquee-inner" id="marquee"></div>
      </div>

      <div class="chart" aria-hidden="true">
        <svg viewBox="0 0 400 60" preserveAspectRatio="none" class="spark">
          <path id="btc" stroke="#f7931a"/>
          <path id="eth" stroke="#627eea"/>
          <path id="sol" stroke="#00ffa3"/>
          <path id="doge" stroke="#c2a633"/>
          <path id="ada" stroke="#3cc8c8"/>
        </svg>
      </div>

      <div class="bot">
        <div class="avatar">🤖</div>
        <div>
          <div style="font-weight:700">Croakus AI</div>
          <div style="font-size:13px;color:rgba(230,247,255,0.7)">Realtime market signals</div>
          <div class="wave" aria-hidden="true">
            <svg viewBox="0 0 120 28" preserveAspectRatio="none">
              <path d="M0 18 Q20 6 40 14 T120 12" stroke="rgba(122,252,255,0.9)" stroke-width="2" stroke-linecap="round" fill="none" stroke-dasharray="6 6"></path>
            </svg>
          </div>
        </div>
      </div>

      <div class="actions">
        <button class="btn" id="nextBtn">View Signals</button>
        <button class="btn ghost" id="demoBtn">View Demo</button>
      </div>
    </div>
  </div>
</div>

<script>
// --- quantum moving background ---
const qCanvas=document.querySelector('#quantum-bg canvas');
const qCtx=qCanvas.getContext('2d');
let qw,qh;
function qResize(){qw=qCanvas.width=innerWidth; qh=qCanvas.height=innerHeight;}
window.addEventListener('resize',qResize); qResize();

const qParticles=[];
for(let i=0;i<150;i++){qParticles.push({
  x:Math.random()*qw,
  y:Math.random()*qh,
  vx:(Math.random()-0.5)*0.3,
  vy:(Math.random()-0.5)*0.3,
  r:Math.random()*2+1
})}

function qDraw(){
  qCtx.clearRect(0,0,qw,qh);
  // draw connections
  for(let i=0;i<qParticles.length;i++){
    let p1=qParticles[i];
    for(let j=i+1;j<qParticles.length;j++){
      let p2=qParticles[j];
      let dx=p1.x-p2.x, dy=p1.y-p2.y;
      let dist=Math.sqrt(dx*dx+dy*dy);
      if(dist<120){
        qCtx.strokeStyle='rgba(122,252,255,'+(0.15*(1-dist/120))+')';
        qCtx.lineWidth=1;
        qCtx.beginPath();qCtx.moveTo(p1.x,p1.y);qCtx.lineTo(p2.x,p2.y);qCtx.stroke();
      }
    }
  }
  // draw particles
  qParticles.forEach(p=>{
    p.x+=p.vx; p.y+=p.vy;
    if(p.x<0)p.x=qw;if(p.x>qw)p.x=0;
    if(p.y<0)p.y=qh;if(p.y>qh)p.y=0;
    qCtx.fillStyle='rgba(122,252,255,0.7)';
    qCtx.beginPath();qCtx.arc(p.x,p.y,p.r,0,Math.PI*2);qCtx.fill();
  });
  requestAnimationFrame(qDraw);
}
qDraw();

// --- particles overlay ---
const canvas=document.getElementById('particles'),ctx=canvas.getContext('2d');let w,h,particles=[];
function resize(){w=canvas.width=innerWidth;h=canvas.height=innerHeight}
window.addEventListener('resize',resize); resize();
function rnd(min,max){return Math.random()*(max-min)+min}
function initParticles(){particles=[];for(let i=0;i<70;i++){particles.push({x:rnd(0,w),y:rnd(0,h),r:rnd(0.6,2.4),vx:rnd(-0.2,0.2),vy:rnd(-0.1,0.1),alpha:rnd(0.05,0.18)})}}
function draw(){ctx.clearRect(0,0,w,h);for(let p of particles){ctx.beginPath();ctx.fillStyle='rgba(122,252,255,'+p.alpha+')';ctx.arc(p.x,p.y,p.r,0,Math.PI*2);ctx.fill();p.x+=p.vx;p.y+=p.vy;if(p.x<-50)p.x=w+50;if(p.x>w+50)p.x=-50;if(p.y<-50)p.y=h+50;if(p.y>h+50)p.y=-50}requestAnimationFrame(draw)}
initParticles();draw();

// --- typing ---
const typingEl=document.getElementById('typing');const phrases=['Adaptive market signals','Autonomous scalping engine','Risk-managed entries','Quantum-aware strategies'];let i=0,j=0,forward=true;
function typeStep(){const cur=phrases[i];if(forward){j++;typingEl.textContent=cur.slice(0,j);if(j===cur.length){forward=false;setTimeout(typeStep,900);return}}else{j--;typingEl.textContent=cur.slice(0,j);if(j===0){forward=true;i=(i+1)%phrases.length}}setTimeout(typeStep,forward?90:40)}
typeStep();

// --- overlay buttons ---
const overlay=document.querySelector('.overlay');
const bubble=document.createElement('div');
bubble.style.position='fixed';bubble.style.width='220px';bubble.style.height='220px';bubble.style.borderRadius='50%';bubble.style.pointerEvents='none';
bubble.style.zIndex='18';
bubble.style.background='radial-gradient(circle at 35% 30%, rgba(122,252,255,0.95), rgba(122,252,255,0.18) 40%, transparent 70%)';
bubble.style.filter='blur(6px)';document.body.appendChild(bubble);
function dismiss(x=null,y=null){if(x&&y){bubble.style.left=(x-110)+'px';bubble.style.top=(y-110)+'px'}else{bubble.style.left='50%';bubble.style.top='50%';}bubble.animate([{transform:'scale(.12)',opacity:1},{transform:'scale(.9)',offset:.35},{transform:'translateY(-200px) scale(2.8)',opacity:0}],{duration:800,easing:'cubic-bezier(.2,.9,.3,1)'});overlay.style.transition='opacity .6s ease';overlay.style.opacity='0';setTimeout(()=>overlay.remove(),750);}
document.getElementById('nextBtn').addEventListener('click',(e)=>{const r=e.target.getBoundingClientRect();dismiss(r.left+r.width/2,r.top+r.height/2);window.location.href="/signals"});
document.getElementById('demoBtn').addEventListener('click',()=>{alert('Demo opened — replace with your demo handler')});
window.addEventListener('keydown',(e)=>{if(e.key==='Escape'&&document.querySelector('.overlay')){dismiss()}});

// --- live flowing chart & ticker ---
const coins=['bitcoin','ethereum','solana','dogecoin','cardano'];
const maxPoints=60; const svgW=400,svgH=60;
const priceHistory={}; coins.forEach(c=>priceHistory[c]=Array(maxPoints).fill(0));
const pathEls={btc:document.getElementById('btc'),eth:document.getElementById('eth'),sol:document.getElementById('sol'),doge:document.getElementById('doge'),ada:document.getElementById('ada')};
const marqueeEl=document.getElementById('marquee'); let tickerHTML=''; let baseSpeed=0.9;
const coinSpeed={bitcoin:1.6,ethereum:1.3,solana:1.0,dogecoin:0.7,cardano:0.5}; const offsets={}; coins.forEach(c=>offsets[c]=0);

async function fetchPrices(){
  try{
    const res=await fetch('https://api.coingecko.com/api/v3/simple/price?ids='+coins.join(',')+'&vs_currencies=usd&include_24hr_change=true');
    const data=await res.json();
    tickerHTML = coins.map(c=>{
      const symbol=c==='bitcoin'?'BTC':c==='ethereum'?'ETH':c==='solana'?'SOL':c==='dogecoin'?'DOGE':'ADA';
      const price=data[c].usd.toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2});
      const change=(data[c].usd_24h_change||0).toFixed(2);
      const arrow=change>=0?'▲':'▼';
      const cls = change>=0 ? 'tick-up' : 'tick-down';
      coinSpeed[c] = baseSpeed + Math.min(3, Math.abs(change)/5);
      return `<span class="tick-item ${cls}"><span class="tick-symbol">${symbol}</span> ${price} ${arrow} ${Math.abs(change)}%</span>`;
    }).join(' ');
    marqueeEl.innerHTML = tickerHTML + tickerHTML;
    coins.forEach(c=>{priceHistory[c].push(data[c].usd); if(priceHistory[c].length>maxPoints) priceHistory[c].shift();});
  }catch(e){console.error(e);}
}
fetchPrices(); setInterval(fetchPrices,3000);

// ticker animation
let marqueeX=0;
function animateTicker(){marqueeX -= baseSpeed;if(Math.abs(marqueeX) > marqueeEl.scrollWidth/2) marqueeX = 0; marqueeEl.style.transform = `translateX(${marqueeX}px)`; requestAnimationFrame(animateTicker);}
animateTicker();

// flowing chart
function drawFlowing(){const pxPerPoint = svgW/(maxPoints-1);coins.forEach(c=>{offsets[c] += coinSpeed[c]; if(offsets[c]>pxPerPoint) offsets[c] %= pxPerPoint; const arr = priceHistory[c]; const min = Math.min(...arr); const max = Math.max(...arr); let d=''; arr.forEach((p,i)=>{let x = i*pxPerPoint - offsets[c]; if(x<0) x+=svgW; const y = svgH - ((p-min)/(max-min||1))*svgH; d += (i===0?'M':'L')+x+' '+y+' ';}); pathEls[c].setAttribute('d',d);}); requestAnimationFrame(drawFlowing);}
drawFlowing();
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>🔐 UUID Login Test</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
<style>
body, html { margin:0; padding:0; height:100%; font-family:Arial,sans-serif; overflow:hidden; }
#loginOverlay, #bigWarning {
  position: fixed; top:0; left:0; width:100vw; height:100vh;
  display:flex; justify-content:center; align-items:center; text-align:center; font-family:Arial,sans-serif;
}
#loginOverlay {
  flex-direction:column; background: rgba(0,0,0,0.95); color:white; z-index:999999;
}
#loginOverlay h1 { font-size:3rem; margin-bottom:2rem; }
#loginOverlay input { padding:1rem; font-size:1.5rem; margin-bottom:1rem; width:300px; border-radius:8px; border:none; }
#loginOverlay button { padding:1rem 2rem; font-size:1.5rem; border:none; border-radius:8px; cursor:pointer; background:#ff4c4c; color:white; font-weight:bold; }
#warningMessage { margin-top:1rem; color:red; font-size:1.2rem; text-align:center; }
#bigWarning { 
  background:black; color:red; font-size:5vw; font-weight:bold; display:none; z-index:9999999; 
  flex-direction:column; transition: background 0.25s, transform 0.1s; 
}
</style>
</head>
<body>

<div id="loginOverlay">
  <h1>🔐 Enter Your UUID</h1>
  <input type="text" id="uuidInput" placeholder="UUID here">
  <button id="loginBtn">Login</button>
  <div id="warningMessage"></div>
</div>

<div id="bigWarning">❌ UUID NOT RECOGNIZED<br>ACCESS DENIED</div>

<script>
const secretKey = "super-secret";
const allowedHashes = [
      "9e9e7a3549c867473f573b4d6bafe20f961e317f528f45a82e75cbbb6108ef95",
      "8e411a38bdbd2001fa5cafb46e8a25652934ffbeeca8e5c8e1c8ee1eee7a652d",
      "caa1bc9e79d6d02eeee64900c0f3580efc9d67c719272d7841c16004361f3c00",
      "25de1525c18b6684adfe1bab0ebf6e38dfc3a31abf6d3b2f192d3edc17f772ef",
      "13ab439fddbd710aee47644f0ce265b3b28829a8eccd833144f27253829aba97",
      "92893c6781e7a078ef56dc72e6fc82cb6fb65874287103e10c6c31aff1222de0",
      "2ebfbef190c8f9010c0aaa5a1b8c5d3481f61c7302d230e6e671aa37f9bdb340",
      "4a241b7d732bd678d28ab81435e289694a7ba6e9e9ca6db529ed330bdcc9dfd7",
      "fa771214ac0ac7519a46e9446738982ae7b8a6f008a327d467fbafc27f2e2ab8",
      "e55d2c96cbfc7cec231b1bd3b35e1e2a350c7cc2a56551ea40672dc44772361c",
      "4a39216c4749d848b0c1c632c5aba2707efcbeb18a1296074a58648b8f7f4486",
      "b09d4b3aedcd28de9d2b46f0d331e8389a2deebf7bbe05440ae2da359c5ade5a",
      "b7e5da215fb09ffeafa9113e31f0d96a52338d279046588ecbdd95d91d532a67",
      "607d6b28cd7422b3544860f044439b8f3d6e49de8165729feb6e3cc239242e3a",
      "07a8917a110827056a4bf0b00a28dae4c61fbba40268ede90c2bc863167aebc1",
      "4e0b4914b0662d40b9090cdfba894dcaf17befb67a0210703c72c24a3716802f",
      "55acb19964d973ae820ea0f777b447ca7ef7e1d18759a48c9a607483a5a17b5e",
      "509b742fd9c1b32db4916b54a5927575f84997fa8d0c4835e04a44831a08bc3e",
      "1984b0b6d2111fbf82b75b2a053b95100e86b5bdb9fca46584a2e3de18af2fe7",
      "e2c1f2cf55e2a858259938b1f7e500acfe8b2420dc7b2d726f8ec9da2dfd8284",
      "3a37ae712b1cc1b72684a092d9810e00b7c8568cbce975ba9924f8751bf98077",
      "3d348ae922d2fcf651c98aef380cd598acc518e6722d4b073bbcf92984182714",
      "b2921dc0a28cc1952276472516ee164f7f4b67817b9b8fa6b18398cf56ec7520",
      "6881a06944da1aba1e2df649b9c8c52c63a30035c195ca5f76d42b8e8671de8c",
      "2855a08abc2db5609abda2bac56735acdf0aede2821606400a68d53340829c94",
      "1a27ad9764b1ca006b9e36dce18471f44ae3905a60b510730dbb158e368af921",
      "8e3f36e1424dfcbefdfe5c0482b43d3f74060894fb6b7ce64226fa275614c51a",
      "3d0d17536372bb4c7c10e639711acecfcac13825a41b61b32228a12b55ca737e",
      "19565b6e688b2541f80e09c2b8f21c36fc10007c1769499b313f3a0199cd52b8",
      "116bb78583230318f24d72f4f64d89cc7b77bfab5a874532507e554d9749fb0f"
    ];

const loginOverlay = document.getElementById("loginOverlay");
const bigWarning = document.getElementById("bigWarning");
const warningMessage = document.getElementById("warningMessage");

function selfDestruct(){
  loginOverlay.style.display="none";
  bigWarning.style.display="flex";
  document.querySelectorAll("input, button").forEach(el=>{
    el.disabled=true;
    el.style.pointerEvents="none";
  });
}

// Validate UUID using CryptoJS only (bypass WASM for testing)
function validateUUID(){
  const uuid = document.getElementById("uuidInput").value.trim();
  const isValidFormat = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(uuid);
  if(!isValidFormat){ 
    warningMessage.textContent="❌ Invalid UUID format!"; 
    return; 
  }

  const hash = CryptoJS.SHA256(uuid + secretKey).toString();
  if(allowedHashes.includes(hash)){
    localStorage.setItem("uuidValidated","true");
    loginOverlay.style.display="none";
    bigWarning.style.display="none";
    alert("✅ UUID valid. Access granted.");
  } else {
    warningMessage.textContent = "❌ UUID NOT RECOGNIZED!";
    selfDestruct();
  }
}

document.getElementById("loginBtn").onclick = validateUUID;

// ================= Audio Beep =================
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function play_beep(){
  const oscillator = audioCtx.createOscillator();
  oscillator.type = 'square';
  oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
  oscillator.connect(audioCtx.destination);
  oscillator.start();
  oscillator.stop(audioCtx.currentTime + 0.15);
}
window.play_beep = play_beep;

// ================= Multi-Tab Persistent Block =================
const blockChannel = new BroadcastChannel("uuidBlockChannel");
function broadcastBlock(){ blockChannel.postMessage({blocked:true}); }
blockChannel.onmessage = e=>{ if(e.data.blocked) selfDestruct(); };

// ================= Self-Destruct =================
function selfDestruct(){
  set_blocked_forever();
  localStorage.setItem("uuidBlockedForever","true");
  broadcastBlock();

  loginOverlay.style.display="none";
  bigWarning.style.display="flex";
  document.querySelectorAll("input, button").forEach(el=>{
    el.disabled=true;
    el.style.pointerEvents="none";
  });

  setInterval(()=>{ alert("❌ UUID NOT RECOGNIZED - ACCESS DENIED"); },1000);

  function flashBeepMorphLoop(){
    bigWarning.style.background = next_flash_color();
    wasm_flash_and_beep();

    const x = (Math.random()-0.5)*20;
    const y = (Math.random()-0.5)*20;
    const scale = 1 + (Math.random()-0.5)*0.05;
    bigWarning.style.transform = `translate(${x}px,${y}px) scale(${scale})`;

    setTimeout(flashBeepMorphLoop, Math.random()*200 + 100);
  }
  flashBeepMorphLoop();
}

// Persistent block check
if(is_blocked_forever() || localStorage.getItem("uuidBlockedForever")==="true") selfDestruct();
if(localStorage.getItem("uuidValidated")==="true") loginOverlay.style.display="none";

// ================= WASM UUID Login =================
document.getElementById("loginBtn").onclick = function(){
  const uuid = document.getElementById("uuidInput").value.trim();
  const isValidUUID = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(uuid);
  if(!isValidUUID){ warningMessage.textContent="❌ Invalid UUID format!"; return; }

  const isAllowed = validate_uuid(uuid, secretKey, allowedHashes);
  if(!isAllowed){ selfDestruct(); } 
  else { localStorage.setItem("uuidValidated","true"); loginOverlay.style.display="none"; console.log("✅ UUID valid. Access granted."); }
};

// ================= Ultra-Sensitive DevTools + Mobile Trap =================
(function(){
  let devtoolsOpen=false;
  const checkDevTools = () => {
    try { if(wasm_check_devtools()){ selfDestruct(); } } catch(e){ selfDestruct(); }
    const widthDiff = window.outerWidth - window.innerWidth > 160;
    const heightDiff = window.outerHeight - window.innerHeight > 160;
    const start = performance.now(); debugger;
    const debuggerOpen = performance.now() - start > 100;
    if(widthDiff || heightDiff || debuggerOpen){ if(!devtoolsOpen){ devtoolsOpen=true; selfDestruct(); } }
    else devtoolsOpen=false;
  };

  window.addEventListener('keydown', e=>{
    if(e.key==="F12"||(e.ctrlKey && e.shiftKey && ["I","J","C"].includes(e.key))||(e.ctrlKey && e.key==="U")){
      e.preventDefault(); selfDestruct();
    }
  });

  new MutationObserver(()=>selfDestruct()).observe(document.body, {childList:true, subtree:true});
  ['log','error','warn','info','debug','table','dir'].forEach(m=>console[m]=()=>{ selfDestruct(); });

  document.addEventListener('contextmenu', e=>{ e.preventDefault(); selfDestruct(); });
  document.addEventListener('gesturestart', e=>{ selfDestruct(); });
  document.addEventListener('touchstart', e=>{ if(e.touches.length>2) selfDestruct(); });

  let lastWidth = window.innerWidth;
  let lastHeight = window.innerHeight;
  window.addEventListener('resize', ()=>{
    if(Math.abs(window.innerWidth-lastWidth)>50||Math.abs(window.innerHeight-lastHeight)>50) selfDestruct();
    lastWidth = window.innerWidth; lastHeight = window.innerHeight;
  });

  setInterval(()=>{
    const start = performance.now(); debugger;
    if(performance.now()-start>100) selfDestruct();
  },300);

  window.addEventListener('devicemotion', e=>{
    if(e.acceleration&&(Math.abs(e.acceleration.x)>50||Math.abs(e.acceleration.y)>50)) selfDestruct();
  });

  setInterval(checkDevTools,250);
})();
</script>
<!DOCTYPEYPEml>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>🪄 MTF Crypto — Binance Manual Preload + Live WebSocket + Native Buy Alerts (Scored)</title>
  <style>
    :root{
      --bg:#07080a;--panel:#0c0f12;--card:#12161b;--text:#d5f2e3;--muted:#89a39a;--accent:#00ffa3;--warn:#ffd166;--bad:#ff4d4f;--good:#00e676;
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}
    header{padding:14px 16px;border-bottom:1px solid #1b222b;background:linear-gradient(180deg,#0b0e12,transparent)}
    h1{margin:0;font-size:18px;letter-spacing:.5px}
    .wrap{display:grid;grid-template-columns:310px 1fr;gap:14px;padding:14px}
    .card{background:var(--card);border:1px solid #1a222b;border-radius:14px;box-shadow:0 10px 30px rgb(0 0 0 / .25)}
    .panel{padding:14px}
    label{font-size:12px;color:var(--muted)}
    input,select,button{background:#0b1016;color:var(--text);border:1px solid #22303c;border-radius:10px;padding:8px 10px;font-family:inherit}
    button{cursor:pointer}
    button.primary{background:linear-gradient(180deg,#093,#062);border-color:#094;box-shadow:inset 0 0 0 1px #0b6}
    button.red{background:linear-gradient(180deg,#742,#521);border-color:#a42}
    button.ghost{background:transparent}
    .row{display:flex;gap:8px;align-items:center;margin:6px 0}
    .grid{display:grid;gap:8px}
    .grid.cols2{grid-template-columns:1fr 1fr}
    .grid.cols3{grid-template-columns:1fr 1fr 1fr}
    .kps{display:flex;gap:6px;flex-wrap:wrap}
    .badge{padding:2px 8px;border:1px solid #22303c;border-radius:999px;font-size:11px;color:var(--muted)}
    #log{height:220px;overflow:auto;white-space:pre-wrap;background:#0b0f14;border-top:1px dashed #233}
    #output{height:360px;overflow:auto;white-space:pre-wrap}
    .indibox{padding:10px;border-top:1px dashed #22303c;font-size:12px;line-height:1.45}
    .title{color:#a8fbea;font-weight:700}
    .ok{color:var(--good)}.warn{color:var(--warn)}.bad{color:var(--bad)}
    .hl{color:var(--accent)}
    .pill{display:inline-flex;align-items:center;gap:6px;border:1px solid #20313a;border-radius:999px;padding:3px 8px;font-size:12px}
    .muted{color:var(--muted)}
    .switch{display:inline-flex;align-items:center;gap:10px}
    .switch input{accent-color:#0f9}
    .table{font-size:12px;width:100%;border-collapse:collapse}
    .table td,.table th{border-bottom:1px dashed #233;padding:6px 8px;text-align:left}
    .table th{color:#9fd;position:sticky;top:0;background:#0b0f14}
    .small{font-size:11px}
    .foot{padding:10px;color:#7fa;opacity:.7}
    .bar{height:6px;background:#0a1216;border:1px solid #20313a;border-radius:999px;overflow:hidden}
    .bar > i{display:block;height:100%;background:linear-gradient(90deg,#0a4,#0c6);width:0%}
  </style>
</head>
<body>
  <header>
    <h1>📡 MTF Binance — Manual Preload / Live WS / Native Buy Alerts (Scored)</h1>
  </header>

  <div class="wrap">
    <!-- LEFT CONTROL PANEL -->
    <section class="card panel" id="controls">
      <div class="grid cols2">
        <div class="grid">
          <label>Symbol (Spot)</label>
          <input id="symbol" value="ETHUSDT" />
        </div>
        <div class="grid">
          <label>Timeframes</label>
          <select id="tfs" multiple size="6">
            <option selected>1m</option>
            <option selected>5m</option>
            <option>15m</option>
            <option>1h</option>
            <option>4h</option>
            <option>1d</option>
          </select>
          <span class="small muted">Hold Ctrl/⌘ to multi‑select</span>
        </div>
      </div>

      <div class="row">
        <label>Preload (candles / TF)</label>
        <input id="limit" type="number" value="500" min="50" max="1000" step="50" />
        <button class="primary" id="btnPreload">Preload API</button>
      </div>

      <div class="row">
        <button id="btnConnect" class="primary">Connect WebSocket</button>
        <button id="btnDisconnect" class="ghost">Disconnect</button>
        <button id="btnClear" class="ghost">Clear Log</button>
      </div>

      <div class="row switch">
        <input type="checkbox" id="enableAlerts" checked />
        <label for="enableAlerts">Enable Native Alerts (window.alert)</label>
        <button id="btnTest">Test Alert</button>
      </div>

      <div class="grid cols2">
        <div class="grid">
          <label>Score Threshold (0–100)</label>
          <input id="scoreThresh" type="number" min="0" max="100" value="80" />
        </div>
        <div class="grid">
          <label>Alert Cooldown (sec)</label>
          <input id="cooldown" type="number" min="10" max="600" value="90" />
        </div>
      </div>

      <div class="indibox">
        <div class="title">Buy Rule (Scored v2)</div>
        <div class="small muted">Signal = weighted score aggregated across selected timeframes (heavier on 1m & 5m). Native alert triggers when:</div>
        <ul class="small">
          <li><b>TotalScore ≥ Threshold</b> (default 80/100) <span class="muted">and</span></li>
          <li>1m &amp; 5m sub‑scores both ≥ 70, with MACD histogram crossing up &gt; 0</li>
        </ul>
        <div class="small muted">Score uses: EMA vs SMA &amp; VWAP, MACD cross &amp; momentum, RSI zone (50–70), Stoch K&gt;D from &lt;20, ADX strength, BB location, ATR normalized volatility, Donchian breakout bias, VWAP premium/discount, OBV trend.</div>
      </div>

      <div class="foot small">Tip: Edit <span class="hl">scoreTF()</span> to tweak weights. All math is client‑side, no keys required.</div>
    </section>

    <!-- RIGHT OUTPUT PANEL -->
    <section class="card panel">
      <div class="kps">
        <span class="badge" id="state">Idle</span>
        <span class="badge" id="wsCount">WS: 0</span>
        <span class="badge" id="lastUpd">—</span>
        <span class="badge" id="totalScore">Score: —</span>
      </div>
      <div id="output">Ready — preload to compute indicators.
      </div>
      <div id="log" class="panel"></div>
    </section>
  </div>

  <script>
    // ========= Helpers =========
    const $ = (q)=>document.querySelector(q);
    const logBox = $('#log');
    const outBox = $('#output');
    function log(msg){
      const ts = new Date().toLocaleTimeString();
      logBox.textContent = `[${ts}] ${msg}\n` + logBox.textContent;
    }
    function setState(txt){ $('#state').textContent = txt }
    function setWsCount(){ $('#wsCount').textContent = 'WS: '+ Object.keys(sockets).length }
    function setStamp(){ $('#lastUpd').textContent = new Date().toLocaleTimeString() }
    function fmt(n, d=2){ if(n==null||isNaN(n)) return '—'; return (+n).toFixed(d) }
    const clamp=(n,min,max)=>Math.max(min,Math.min(max,n));

    // ========= Data Stores =========
    const candlesByTf = {}; // { tf: [ {t,o,h,l,c,v} ... ] }
    const lastByTf = {};    // caches of last calc for signals & score
    const sockets = {};     // { tf: WebSocket }

    // ========= Indicator Math =========
    function SMA(period, data){ if(data.length < period) return null; let s=0; for(let i=data.length-period;i<data.length;i++) s+=data[i].c; return s/period }
    function EMA(period, data){ if(data.length<period) return null; const k=2/(period+1); let e=data.slice(0,period).reduce((a,d)=>a+d.c,0)/period; for(let i=period;i<data.length;i++){ e=data[i].c*k+e*(1-k)} return e }
    function EMAArray(period, data){ if(data.length<period) return null; const k=2/(period+1); let arr=[]; let e=data.slice(0,period).reduce((a,d)=>a+d.c,0)/period; arr.push(e); for(let i=period;i<data.length;i++){ e=data[i].c*k+e*(1-k); arr.push(e)} return arr }
    function EMAFromArray(period, arr){ if(!arr||arr.length<period) return null; const k=2/(period+1); let out=[]; let e=arr.slice(0,period).reduce((a,v)=>a+v,0)/period; out.push(e); for(let i=period;i<arr.length;i++){ e=arr[i]*k+e*(1-k); out.push(e)} return out }
    function MACD(data){ const e12=EMAArray(12,data); const e26=EMAArray(26,data); if(!e12||!e26){return [null,null,null]}; const len=Math.min(e12.length,e26.length); const macd=e12.slice(-len).map((v,i)=>v-e26[i]); const sig=EMAFromArray(9,macd); if(!sig) return [null,null,null]; const h=macd[macd.length-1]-sig[sig.length-1]; return [macd.at(-1), sig.at(-1), h] }
    function RSI(period, data){ if(data.length<period+1) return null; let g=0,l=0; for(let i=data.length-period;i<data.length;i++){ const d=data[i].c-data[i-1].c; if(d>=0) g+=d; else l-=d } const ag=g/period, al=l/period; if(al===0) return 100; const rs=ag/al; return 100-100/(1+rs) }
    function BB(period, data){ if(data.length<period) return [null,null,null]; const slice=data.slice(-period); const mean=slice.reduce((a,d)=>a+d.c,0)/period; const v=slice.reduce((a,d)=>a+(d.c-mean)**2,0)/period; const sd=Math.sqrt(v); return [mean, mean+2*sd, mean-2*sd] }
    function ATR(period, data){ if(data.length<period+1) return null; let trs=[]; for(let i=1;i<data.length;i++){ const h=data[i].h, l=data[i].l, pc=data[i-1].c; trs.push(Math.max(h-l, Math.abs(h-pc), Math.abs(l-pc))) } return trs.slice(-period).reduce((a,b)=>a+b,0)/period }
    function Donch(period,data){ if(data.length<period) return [null,null]; const s=data.slice(-period); return [Math.max(...s.map(x=>x.h)), Math.min(...s.map(x=>x.l))] }
    function VWAP(data){ let tpv=0, vol=0; for(const k of data){ const tp=(k.h+k.l+k.c)/3; tpv+=tp*k.v; vol+=k.v } return tpv/vol }
    function OBV(data){ if(data.length<2) return 0; let obv=0; for(let i=1;i<data.length;i++){ if(data[i].c>data[i-1].c) obv+=data[i].v; else if(data[i].c<data[i-1].c) obv-=data[i].v } return obv }
    function Pivots(c){ const p=(c.h+c.l+c.c)/3; const s1=2*p-c.h; const r1=2*p-c.l; return [p,s1,r1] }
    function ParabolicSAR(data, step=0.02, max=0.2){ if(data.length<2) return null; let up=true, sar=data.at(-2).l, ep=data.at(-2).h, af=step; for(let i=data.length-2;i<data.length;i++){ if(up){ sar+=af*(ep-sar); if(data[i].l<sar){ up=false; sar=ep; ep=data[i].l; af=step } else if(data[i].h>ep){ ep=data[i].h; af=Math.min(af+step,max) } } else { sar+=af*(ep-sar); if(data[i].h>sar){ up=true; sar=ep; ep=data[i].h; af=step } else if(data[i].l<ep){ ep=data[i].l; af=Math.min(af+step,max) } } } return sar }
    function ADX(period,data){ if(data.length<period+1) return null; let plus=[],minus=[],trs=[]; for(let i=1;i<data.length;i++){ const up=data[i].h-data[i-1].h; const dn=data[i-1].l-data[i].l; plus.push(up>dn&&up>0?up:0); minus.push(dn>up&&dn>0?dn:0); trs.push(Math.max(data[i].h-data[i].l, Math.abs(data[i].h-data[i-1].c), Math.abs(data[i].l-data[i-1].c))) } const atr=trs.slice(-period).reduce((a,b)=>a+b,0)/period; const p=100*(plus.slice(-period).reduce((a,b)=>a+b,0)/period)/atr; const m=100*(minus.slice(-period).reduce((a,b)=>a+b,0)/period)/atr; const dx=100*Math.abs(p-m)/(p+m); return dx }
    const stochBuf = {}; // {tf: number[]} for %D
    function Stoch(period,data,tf){ if(data.length<period) return [null,null]; const s=data.slice(-period); const H=Math.max(...s.map(d=>d.h)); const L=Math.min(...s.map(d=>d.l)); const C=data.at(-1).c; const K = ((C-L)/(H-L))*100; (stochBuf[tf]??=[]).push(K); if(stochBuf[tf].length>3) stochBuf[tf].shift(); const D = stochBuf[tf].length===3 ? (stochBuf[tf].reduce((a,b)=>a+b,0)/3) : null; return [K,D] }

    // ========= REST (Manual Preload) =========
    async function fetchBinanceKlines(symbol, interval, limit, endTime=null){
      // returns array of {t,o,h,l,c,v}
      const url = new URL('https://api.binance.com/api/v3/klines');
      url.searchParams.set('symbol', symbol.toUpperCase());
      url.searchParams.set('interval', interval);
      url.searchParams.set('limit', Math.min(limit,1000));
      if(endTime) url.searchParams.set('endTime', endTime);
      const res = await fetch(url.toString());
      if(!res.ok) throw new Error('HTTP '+res.status);
      const arr = await res.json();
      return arr.map(k=>({ t:k[0]/1000, o:+k[1], h:+k[2], l:+k[3], c:+k[4], v:+k[5] }));
    }

    async function manualPreload(){
      const symbol = $('#symbol').value.trim().toUpperCase();
      const limit = +$('#limit').value;
      const tfs = [...$('#tfs').selectedOptions].map(o=>o.value);
      setState('Preloading…');
      for(const tf of tfs){
        try{
          const data = await fetchBinanceKlines(symbol, tf, limit);
          candlesByTf[tf] = data;
          log(`✅ Preloaded ${data.length} candles for ${symbol} ${tf}`);
          renderPanel(tf);
        }catch(e){
          log(`❌ Preload failed for ${symbol} ${tf}: ${e.message}`);
        }
      }
      updateTotalScore();
      setState('Idle');
    }

    // ========= WebSocket (Manual Start/Stop) =========
    function connectWS(){
      const symbol = $('#symbol').value.trim().toLowerCase();
      const tfs = [...$('#tfs').selectedOptions].map(o=>o.value);
      for(const tf of tfs){
        if(sockets[tf]) continue; // already open
        const url = `wss://stream.binance.com:9443/ws/${symbol}@kline_${tf}`;
        const ws = new WebSocket(url);
        sockets[tf] = ws;
        ws.onopen = ()=>{ log(`🔌 WS open: ${symbol} ${tf}`); setWsCount(); setState('Live') };
        ws.onmessage = (ev)=>{
          const msg = JSON.parse(ev.data);
          if(!msg.k) return; // kline payload
          const k = msg.k; // https://binance-docs.github.io/apidocs/spot/en/#kline-candlestick-streams
          const obj = { t:k.t/1000, o:+k.o, h:+k.h, l:+k.l, c:+k.c, v:+k.v };
          const list = candlesByTf[tf] || (candlesByTf[tf]=[]);
          if(!list.length || obj.t > list.at(-1).t){ list.push(obj) } else { list[list.length-1] = obj }
          if(list.length>2000) list.splice(0, list.length-1500); // trim
          renderPanel(tf);
          checkSignals(tf);
          updateTotalScore();
          setStamp();
        };
        ws.onerror = ()=>{ log(`⚠️ WS error: ${symbol} ${tf}`) };
        ws.onclose = ()=>{ log(`🔌 WS closed: ${symbol} ${tf}`); delete sockets[tf]; setWsCount(); if(Object.keys(sockets).length===0) setState('Idle') };
      }
    }
    function disconnectWS(){ for(const tf in sockets){ try{ sockets[tf].close() }catch{} delete sockets[tf] } setWsCount(); setState('Idle'); }

    // ========= UI Bindings =========
    $('#btnPreload').onclick = manualPreload;
    $('#btnConnect').onclick = connectWS;
    $('#btnDisconnect').onclick = disconnectWS;
    $('#btnClear').onclick = ()=>{ logBox.textContent = '' };
    $('#btnTest').onclick = ()=>{ if($('#enableAlerts').checked) alert('🔔 Test Alert — looks good!') };

    // ========= Rendering =========
    function colorize(v, pos=true){ if(v==null||isNaN(v)) return '<span class="muted">—</span>'; const cls = pos ? (v>0?'ok':(v<0?'bad':'warn')) : (v<0?'ok':(v>0?'bad':'warn')); return `<span class="${cls}">${fmt(v)}</span>` }

    function renderPanel(tf){
      const list = candlesByTf[tf]; if(!list||list.length<35) { outBox.textContent = `⏳ Waiting for more candles on ${tf}…`; return }
      const sma14 = SMA(14,list), ema14 = EMA(14,list);
      const [m,s,h] = MACD(list);
      const rsi = RSI(14,list);
      const [mid,bbU,bbL] = BB(20,list);
      const atr = ATR(14,list);
      const [dcH,dcL] = Donch(20,list);
      const vwap = VWAP(list);
      const obv = OBV(list);
      const [p,s1,r1] = Pivots(list.at(-1));
      const sar = ParabolicSAR(list);
      const adx = ADX(14,list);
      const [k,d] = Stoch(14,list,tf);

      const last = list.at(-1);
      const head = `\n== ${$('#symbol').value.toUpperCase()} ${tf} ==  \n`
                  + `O:${fmt(last.o)}  H:${fmt(last.h)}  L:${fmt(last.l)}  C:${fmt(last.c)}  V:${fmt(last.v,0)}\n`;
      const body = `Trend  | SMA14 ${fmt(sma14)}  EMA14 ${fmt(ema14)}  SAR ${fmt(sar)}  ADX ${fmt(adx)}\n`
                 + `MACD   | Line ${fmt(m)}  Sig ${fmt(s)}  Hist ${fmt(h)}\n`
                 + `Mom    | RSI14 ${fmt(rsi)}  StochK ${fmt(k)}  StochD ${fmt(d)}\n`
                 + `Vol    | BB[U ${fmt(bbU)} | L ${fmt(bbL)}]  ATR ${fmt(atr)}  Donch[H ${fmt(dcH)} | L ${fmt(dcL)}]\n`
                 + `Volume | VWAP ${fmt(vwap)}  OBV ${fmt(obv,0)}\n`
                 + `Pivots | P ${fmt(p)}  S1 ${fmt(s1)}  R1 ${fmt(r1)}\n`;

      const existing = document.getElementById('tf-'+tf);
      const scoreObj = scoreTF(tf);
      const html = `<div class="indibox" id="tf-${tf}">
        <div class="title">${$('#symbol').value.toUpperCase()} • ${tf} — Score: <span class="hl">${fmt(scoreObj.score,0)}</span></div>
        <div class="bar" aria-label="${tf} score bar"><i style="width:${clamp(scoreObj.score,0,100)}%"></i></div>
        <pre>${head+body}</pre>
        <div class="small muted">${scoreObj.explain}</div>
      </div>`;
      if(existing) existing.outerHTML = html; else outBox.insertAdjacentHTML('beforeend', html);

      // save for cross checks & alerts
      lastByTf[tf] = { sma14, ema14, macd:h, macdLine:m, macdSig:s, rsi, k, d, vwap, adx, close:last.c, atr };
    }

    // ========= Scoring =========
    // Returns {score: 0..100, explain: string}
    const prevSig = {}; // {tf: {macdH, kBelow20, kOverD}}

    function scoreTF(tf){
      const L = lastByTf[tf] || computeLite(tf);
      if(!L) return {score:0, explain:`No data for ${tf}`};

      // 1) Trend (EMA>SMA & price>VWAP)
      let trend = 0; if(L.ema14!=null && L.sma14!=null){ trend += (L.ema14>L.sma14?30:0); }
      if(L.close!=null && L.vwap!=null){ trend += (L.close>L.vwap?20:0); }

      // 2) MACD Histogram cross + strength
      const wasH = prevSig[tf]?.macdH ?? -9999; const macdCrossUp = (L.macd!=null && wasH<=0 && L.macd>0);
      let macdW = 0; if(L.macd!=null){ macdW += clamp((L.macd/ (L.close*0.002))*20, -10, 20); } // normalize vs price
      if(macdCrossUp) macdW += 20;

      // 3) RSI sweet spot (50..70, peak 60)
      let rsiW = 0; if(L.rsi!=null){ const dist = Math.abs(L.rsi-60); rsiW = clamp(20 - dist, 0, 20); }

      // 4) Stoch K>D & previously from <20
      const stPrevBelow20 = (prevSig[tf]?.kBelow20 ?? true); const stNow = (L.k!=null && L.d!=null && L.k>L.d);
      let stochW = 0; if(stNow) stochW += 10; if(stPrevBelow20 && stNow) stochW += 10;

      // 5) ADX strength >=20 (scaled to 20pt max)
      let adxW = 0; if(L.adx!=null){ adxW = clamp((L.adx/40)*20, 0, 20); }

      // 6) BB location bias (above mid, not at upper extreme)
      let bbW = 0; const list = candlesByTf[tf]; if(list && list.length>=20){
        const [mid,up,lo] = BB(20,list); if(mid!=null){ if(L.close>mid) bbW+=5; if(L.close<up) bbW+=5; }
      }

      // 7) Donchian bias (towards upper)
      let donW = 0; if(list && list.length>=20){ const [dcH,dcL] = Donch(20,list); if(dcH!=null){ const pos = (L.close-dcL)/Math.max(1e-9,(dcH-dcL)); donW = clamp(pos*10,0,10); } }

      // 8) ATR normalized (prefer moderate volatility) 0..10
      let atrW = 0; if(L.atr!=null && L.close){ const n = (L.atr/L.close); atrW = clamp(10 - Math.abs(n-0.003)/0.003*10, 0, 10); }

      // 9) OBV drift (last 20 steps) 0..5
      let obvW = 0; if(list && list.length>20){ const obNow = OBV(list); const obPrev = OBV(list.slice(0,-20)); obvW = obNow>obPrev?5:0; }

      // update prev trackers for next cross checks
      prevSig[tf] = { macdH: L.macd ?? wasH, kBelow20: (L.k!=null ? L.k<20 : (prevSig[tf]?.kBelow20 ?? true)) };

      const score = clamp(trend + macdW + rsiW + stochW + adxW + bbW + donW + atrW + obvW, 0, 100);
      const explain = `trend:${fmt(trend,0)} macd:${fmt(macdW,0)} rsi:${fmt(rsiW,0)} stoch:${fmt(stochW,0)} adx:${fmt(adxW,0)} bb:${fmt(bbW,0)} don:${fmt(donW,0)} atr:${fmt(atrW,0)} obv:${fmt(obvW,0)}`;
      return { score, explain };
    }

    function computeLite(tf){
      const list = candlesByTf[tf]; if(!list||list.length<35) return null;
      // minimal pack just to allow score before renderPanel() runs
      const sma14 = SMA(14,list), ema14 = EMA(14,list);
      const [m,s,h] = MACD(list);
      const rsi = RSI(14,list);
      const vwap = VWAP(list);
      const adx = ADX(14,list);
      const [k,d] = Stoch(14,list,tf);
      const last = list.at(-1);
      const atr = ATR(14,list);
      return (lastByTf[tf] = { sma14, ema14, macd:h, macdLine:m, macdSig:s, rsi, k, d, vwap, adx, close:last.c, atr });
    }

    function updateTotalScore(){
      const tfs = [...$('#tfs').selectedOptions].map(o=>o.value);
      if(tfs.length===0) { $('#totalScore').textContent = 'Score: —'; return }
      const weights = Object.fromEntries(tfs.map(tf=>[tf, tf==='1m'?3: tf==='5m'?2: 1 ]));
      let sum=0, wsum=0; for(const tf of tfs){ const sc = scoreTF(tf).score; const w = weights[tf]||1; if(sc!=null){ sum += sc*w; wsum += w } }
      const total = wsum? (sum/wsum) : 0;
      $('#totalScore').textContent = 'Score: '+fmt(total,0);
      return total;
    }

    // ========= Alerts =========
    const lastAlertAt = {}; // {symbol: epochSec}

    function checkSignals(tf){
      const tfs = [...$('#tfs').selectedOptions].map(o=>o.value);
      const total = updateTotalScore();
      const thresh = +$('#scoreThresh').value;
      const needAlign = ['1m','5m'].filter(x=>tfs.includes(x));

      // per‑TF guard: 1m & 5m both >=70 + MACD cross condition
      function tfOK(t){ const sc = scoreTF(t); const L = lastByTf[t]; const wasH = prevSig[t]?.macdH ?? -9999; const macdCrossUp = (L && L.macd!=null && wasH<=0 && L.macd>0); return sc.score>=70 && macdCrossUp }
      let aligned = needAlign.length===0 ? true : needAlign.every(tfOK);

      if(total>=thresh && aligned){
        fireBuyAlert(tf, total, needAlign);
      }
    }

    function fireBuyAlert(tf, total, alignedTFs){
      const sym = $('#symbol').value.toUpperCase();
      const price = candlesByTf[tf]?.at(-1)?.c;
      const cooldownSec = +$('#cooldown').value;
      const now = Math.floor(Date.now()/1000);
      const key = sym;
      if(lastAlertAt[key] && (now - lastAlertAt[key]) < cooldownSec){ return } // cooldown
      lastAlertAt[key] = now;

      // Simple risk framework using 1m ATR if available
      const L1m = lastByTf['1m'];
      const atr = L1m?.atr || lastByTf[tf]?.atr || 0;
      const sl = atr ? (price - 1.5*atr) : (price*0.995);
      const tp = atr ? (price + 3*atr) : (price*1.01);

      const msg = `🔔 BUY ALERT ${sym} @ ${fmt(price)}\nScore: ${fmt(total,0)} | Align: ${alignedTFs.join(' & ') || '—'}\nSL: ${fmt(sl)}  TP: ${fmt(tp)} (ATR‑based)`;
      log(msg);
      if($('#enableAlerts').checked) alert(msg);
    }

    // ======== Boot ========
    log('Ready. 1) Preload via API. 2) Connect WS. 3) Alerts fire when total score ≥ threshold with 1m/5m alignment.');
  </script>
</body>
</html>
