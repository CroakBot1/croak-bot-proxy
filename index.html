<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>‚öõ Quantum Trading</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&display=swap" rel="stylesheet">

  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Orbitron', sans-serif;
      background: #000;
      color: #e0e0ff;
      min-height: 100vh;
      overflow-x: hidden;
    }

    /* Overlay style */
    .overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.95);
      z-index: 9999;
      display: flex;
      flex-direction: column;
      animation: fadeIn 0.6s ease;
    }

    .overlay.fade-out {
      animation: fadeOut 0.8s ease forwards;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    @keyframes fadeOut {
      from { opacity: 1; }
      to { opacity: 0; visibility: hidden; }
    }

    canvas#quantum-bg {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: -1;
      background: radial-gradient(circle at center, #030b1a, #000);
    }

    header {
      background: rgba(10, 15, 40, 0.8);
      padding: 20px 40px;
      border-bottom: 2px solid #1ef5ff;
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: sticky;
      top: 0;
      z-index: 10;
    }
    header h1 {
      font-size: 1.8rem;
      color: #1ef5ff;
      text-shadow: 0 0 10px #00eaff, 0 0 20px #0088ff;
    }
    nav a {
      margin-left: 25px;
      text-decoration: none;
      color: #e0e0ff;
      font-weight: 500;
      transition: color .3s;
    }
    nav a:hover { color: #1ef5ff; }

    .hero {
      height: 75vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      position: relative;
    }
    .hero-content {
      position: relative;
      z-index: 2;
      color: #fff;
    }
    .hero h2 {
      font-size: 3rem;
      color: #1ef5ff;
      margin-bottom: 15px;
      text-shadow: 0 0 15px #00ffff;
    }
    .hero p {
      font-size: 1.2rem;
      max-width: 600px;
      margin: auto;
    }
    .btn {
      margin-top: 20px;
      padding: 12px 25px;
      background: linear-gradient(90deg, #1ef5ff, #5b2bff);
      color: #fff;
      border: none;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
      transition: 0.3s;
      box-shadow: 0 0 15px #1ef5ff;
    }
    .btn:hover { transform: scale(1.05); }

    .section {
      padding: 60px 40px;
      max-width: 1200px;
      margin: auto;
      position: relative;
      z-index: 2;
    }
    .section h3 {
      text-align: center;
      font-size: 2rem;
      margin-bottom: 25px;
      color: #1ef5ff;
      text-shadow: 0 0 10px #00ffff;
    }
    .section p {
      max-width: 900px;
      margin: auto;
      text-align: center;
      font-size: 1.1rem;
      line-height: 1.6rem;
      margin-bottom: 40px;
      color: #ccc;
    }
    .cards {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 25px;
    }
    .card {
      background: rgba(20, 25, 55, 0.85);
      padding: 25px;
      border-radius: 15px;
      text-align: center;
      border: 1px solid #1ef5ff33;
      transition: 0.4s;
    }
    .card:hover {
      transform: translateY(-8px);
      border-color: #1ef5ff;
      box-shadow: 0 0 20px #1ef5ff55;
    }
    footer {
      text-align: center;
      padding: 20px;
      background: #050a1a;
      color: #888;
      border-top: 1px solid #1ef5ff33;
      position: relative;
      z-index: 2;
    }
  </style>
</head>
<body>

  <!-- Overlay Wrapper -->
  <div class="overlay" id="overlay">
    <!-- Quantum Animated Background -->
    <canvas id="quantum-bg"></canvas>

    <header>
      <h1>‚öõ Quantum Trading</h1>
      <nav>
        <a href="#">Home</a>
        <a href="#about">About</a>
        <a href="#works">How It Works</a>
        <a href="#why">Why Us</a>
        <a href="#contact">Contact</a>
      </nav>
    </header>

    <section class="hero">
      <div class="hero-content">
        <h2>The Future of Trading</h2>
        <p>Harness the power of quantum algorithms and AI-driven analysis to trade smarter, faster, and with unmatched precision.</p>
        <button class="btn" id="nextBtn">Get Started</button>
      </div>
    </section>

    <!-- About Section -->
    <section class="section" id="about">
      <h3>‚öõ About Quantum Trading</h3>
      <p>Quantum Trading is a revolutionary platform that combines the principles of quantum-inspired algorithms and artificial intelligence to optimize financial decisions. Unlike traditional trading systems, Quantum Trading explores multiple probabilities simultaneously, giving traders a significant edge in speed, accuracy, and risk management.</p>
    </section>

    <!-- How It Works Section -->
    <section class="section" id="works">
      <h3>üî¨ How It Works</h3>
      <p>Our system uses advanced mathematical models inspired by quantum computing. This allows us to process massive amounts of data in parallel, identify hidden patterns, and predict price movements with high probability. The process follows three core steps:</p>
      <div class="cards">
        <div class="card">
          <h4>1. Data Collection</h4>
          <p>Market data is gathered from multiple exchanges, including order books, liquidity flows, and news sentiment.</p>
        </div>
        <div class="card">
          <h4>2. Quantum Analysis</h4>
          <p>Our algorithms analyze all possible outcomes simultaneously, identifying the most probable profitable trades.</p>
        </div>
        <div class="card">
          <h4>3. Execution</h4>
          <p>Trades are executed instantly with smart risk controls and automated stop-loss/take-profit management.</p>
        </div>
      </div>
    </section>

    <!-- Why Choose Us Section -->
    <section class="section" id="why">
      <h3>üåå Why Choose Quantum Trading?</h3>
      <p>We are not just another trading platform. Our system is designed for the future, combining AI, quantum-inspired technology, and professional-grade execution tools.</p>
      <div class="cards">
        <div class="card">
          <h4>‚ö° Speed Advantage</h4>
          <p>Process market changes in milliseconds with lightning-fast trade execution.</p>
        </div>
        <div class="card">
          <h4>üéØ Precision</h4>
          <p>Our probability-driven models minimize risk and maximize accuracy.</p>
        </div>
        <div class="card">
          <h4>üîê Security</h4>
          <p>All trades are executed with enterprise-grade encryption and safety protocols.</p>
        </div>
      </div>
    </section>

    <footer id="contact">
      <p>‚öõ Quantum Trading ¬© 2025 | All Rights Reserved</p>
      <p>üìß Contact: support@quantumtrading.ai</p>
    </footer>
  </div>

  <script>
    // Quantum Particle Background
    const canvas = document.getElementById("quantum-bg");
    const ctx = canvas.getContext("2d");
    let particlesArray;

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    window.addEventListener("resize", function(){
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      init();
    });

    class Particle {
      constructor(x, y, directionX, directionY, size, color){
        this.x = x;
        this.y = y;
        this.directionX = directionX;
        this.directionY = directionY;
        this.size = size;
        this.color = color;
      }
      draw(){
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2, false);
        ctx.fillStyle = this.color;
        ctx.shadowBlur = 15;
        ctx.shadowColor = this.color;
        ctx.fill();
      }
      update(){
        if(this.x > canvas.width || this.x < 0){ this.directionX = -this.directionX; }
        if(this.y > canvas.height || this.y < 0){ this.directionY = -this.directionY; }
        this.x += this.directionX;
        this.y += this.directionY;
        this.draw();
      }
    }

    function init(){
      particlesArray = [];
      let numberOfParticles = (canvas.width * canvas.height) / 15000;
      for(let i=0; i<numberOfParticles; i++){
        let size = (Math.random() * 2) + 1;
        let x = Math.random() * (innerWidth - size * 2);
        let y = Math.random() * (innerHeight - size * 2);
        let directionX = (Math.random() * 0.6) - 0.3;
        let directionY = (Math.random() * 0.6) - 0.3;
        let color = Math.random() > 0.5 ? "#1ef5ff" : "#5b2bff";
        particlesArray.push(new Particle(x, y, directionX, directionY, size, color));
      }
    }

    function connect(){
      let opacityValue = 1;
      for(let a=0; a<particlesArray.length; a++){
        for(let b=a; b<particlesArray.length; b++){
          let distance = ((particlesArray[a].x - particlesArray[b].x) ** 2) 
          + ((particlesArray[a].y - particlesArray[b].y) ** 2);
          if(distance < (canvas.width/7) * (canvas.height/7)){
            opacityValue = 1 - (distance/20000);
            ctx.strokeStyle = "rgba(30,245,255,"+opacityValue+")";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(particlesArray[a].x, particlesArray[a].y);
            ctx.lineTo(particlesArray[b].x, particlesArray[b].y);
            ctx.stroke();
          }
        }
      }
    }

    function animate(){
      requestAnimationFrame(animate);
      ctx.clearRect(0,0,innerWidth,innerHeight);
      for(let i=0; i<particlesArray.length; i++){
        particlesArray[i].update();
      }
      connect();
    }

    init();
    animate();

    // ====== Get Started Button Logic ======
    const nextBtn = document.getElementById("nextBtn");
    const overlay = document.getElementById("overlay");

    nextBtn.addEventListener("click", () => {
      overlay.classList.add("fade-out"); // fade-out effect
      setTimeout(() => {
        overlay.style.display = "none"; // remove overlay
      }, 800); // match transition speed
    });
  </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>üîê UUID Login Test</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
<style>
body, html { margin:0; padding:0; height:100%; font-family:Arial,sans-serif; overflow:hidden; }
#loginOverlay, #bigWarning {
  position: fixed; top:0; left:0; width:100vw; height:100vh;
  display:flex; justify-content:center; align-items:center; text-align:center; font-family:Arial,sans-serif;
}
#loginOverlay {
  flex-direction:column; background: rgba(0,0,0,0.95); color:white; z-index:999999;
}
#loginOverlay h1 { font-size:3rem; margin-bottom:2rem; }
#loginOverlay input { padding:1rem; font-size:1.5rem; margin-bottom:1rem; width:300px; border-radius:8px; border:none; }
#loginOverlay button { padding:1rem 2rem; font-size:1.5rem; border:none; border-radius:8px; cursor:pointer; background:#ff4c4c; color:white; font-weight:bold; }
#warningMessage { margin-top:1rem; color:red; font-size:1.2rem; text-align:center; }
#bigWarning { 
  background:black; color:red; font-size:5vw; font-weight:bold; display:none; z-index:9999999; 
  flex-direction:column; transition: background 0.25s, transform 0.1s; 
}
</style>
</head>
<body>

<div id="loginOverlay">
  <h1>üîê Enter Your UUID</h1>
  <input type="text" id="uuidInput" placeholder="UUID here">
  <button id="loginBtn">Login</button>
  <div id="warningMessage"></div>
</div>

<div id="bigWarning">‚ùå UUID NOT RECOGNIZED<br>ACCESS DENIED</div>

<script>
const secretKey = "super-secret";
const allowedHashes = [
      "9e9e7a3549c867473f573b4d6bafe20f961e317f528f45a82e75cbbb6108ef95",
      "8e411a38bdbd2001fa5cafb46e8a25652934ffbeeca8e5c8e1c8ee1eee7a652d",
      "caa1bc9e79d6d02eeee64900c0f3580efc9d67c719272d7841c16004361f3c00",
      "25de1525c18b6684adfe1bab0ebf6e38dfc3a31abf6d3b2f192d3edc17f772ef",
      "13ab439fddbd710aee47644f0ce265b3b28829a8eccd833144f27253829aba97",
      "92893c6781e7a078ef56dc72e6fc82cb6fb65874287103e10c6c31aff1222de0",
      "2ebfbef190c8f9010c0aaa5a1b8c5d3481f61c7302d230e6e671aa37f9bdb340",
      "4a241b7d732bd678d28ab81435e289694a7ba6e9e9ca6db529ed330bdcc9dfd7",
      "fa771214ac0ac7519a46e9446738982ae7b8a6f008a327d467fbafc27f2e2ab8",
      "e55d2c96cbfc7cec231b1bd3b35e1e2a350c7cc2a56551ea40672dc44772361c",
      "4a39216c4749d848b0c1c632c5aba2707efcbeb18a1296074a58648b8f7f4486",
      "b09d4b3aedcd28de9d2b46f0d331e8389a2deebf7bbe05440ae2da359c5ade5a",
      "b7e5da215fb09ffeafa9113e31f0d96a52338d279046588ecbdd95d91d532a67",
      "607d6b28cd7422b3544860f044439b8f3d6e49de8165729feb6e3cc239242e3a",
      "07a8917a110827056a4bf0b00a28dae4c61fbba40268ede90c2bc863167aebc1",
      "4e0b4914b0662d40b9090cdfba894dcaf17befb67a0210703c72c24a3716802f",
      "55acb19964d973ae820ea0f777b447ca7ef7e1d18759a48c9a607483a5a17b5e",
      "509b742fd9c1b32db4916b54a5927575f84997fa8d0c4835e04a44831a08bc3e",
      "1984b0b6d2111fbf82b75b2a053b95100e86b5bdb9fca46584a2e3de18af2fe7",
      "e2c1f2cf55e2a858259938b1f7e500acfe8b2420dc7b2d726f8ec9da2dfd8284",
      "3a37ae712b1cc1b72684a092d9810e00b7c8568cbce975ba9924f8751bf98077",
      "3d348ae922d2fcf651c98aef380cd598acc518e6722d4b073bbcf92984182714",
      "b2921dc0a28cc1952276472516ee164f7f4b67817b9b8fa6b18398cf56ec7520",
      "6881a06944da1aba1e2df649b9c8c52c63a30035c195ca5f76d42b8e8671de8c",
      "2855a08abc2db5609abda2bac56735acdf0aede2821606400a68d53340829c94",
      "1a27ad9764b1ca006b9e36dce18471f44ae3905a60b510730dbb158e368af921",
      "8e3f36e1424dfcbefdfe5c0482b43d3f74060894fb6b7ce64226fa275614c51a",
      "3d0d17536372bb4c7c10e639711acecfcac13825a41b61b32228a12b55ca737e",
      "19565b6e688b2541f80e09c2b8f21c36fc10007c1769499b313f3a0199cd52b8",
      "116bb78583230318f24d72f4f64d89cc7b77bfab5a874532507e554d9749fb0f"
    ];

const loginOverlay = document.getElementById("loginOverlay");
const bigWarning = document.getElementById("bigWarning");
const warningMessage = document.getElementById("warningMessage");

function selfDestruct(){
  loginOverlay.style.display="none";
  bigWarning.style.display="flex";
  document.querySelectorAll("input, button").forEach(el=>{
    el.disabled=true;
    el.style.pointerEvents="none";
  });
}

// Validate UUID using CryptoJS only (bypass WASM for testing)
function validateUUID(){
  const uuid = document.getElementById("uuidInput").value.trim();
  const isValidFormat = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(uuid);
  if(!isValidFormat){ 
    warningMessage.textContent="‚ùå Invalid UUID format!"; 
    return; 
  }

  const hash = CryptoJS.SHA256(uuid + secretKey).toString();
  if(allowedHashes.includes(hash)){
    localStorage.setItem("uuidValidated","true");
    loginOverlay.style.display="none";
    bigWarning.style.display="none";
    alert("‚úÖ UUID valid. Access granted.");
  } else {
    warningMessage.textContent = "‚ùå UUID NOT RECOGNIZED!";
    selfDestruct();
  }
}

document.getElementById("loginBtn").onclick = validateUUID;

// ================= Audio Beep =================
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function play_beep(){
  const oscillator = audioCtx.createOscillator();
  oscillator.type = 'square';
  oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
  oscillator.connect(audioCtx.destination);
  oscillator.start();
  oscillator.stop(audioCtx.currentTime + 0.15);
}
window.play_beep = play_beep;

// ================= Multi-Tab Persistent Block =================
const blockChannel = new BroadcastChannel("uuidBlockChannel");
function broadcastBlock(){ blockChannel.postMessage({blocked:true}); }
blockChannel.onmessage = e=>{ if(e.data.blocked) selfDestruct(); };

// ================= Self-Destruct =================
function selfDestruct(){
  set_blocked_forever();
  localStorage.setItem("uuidBlockedForever","true");
  broadcastBlock();

  loginOverlay.style.display="none";
  bigWarning.style.display="flex";
  document.querySelectorAll("input, button").forEach(el=>{
    el.disabled=true;
    el.style.pointerEvents="none";
  });

  setInterval(()=>{ alert("‚ùå UUID NOT RECOGNIZED - ACCESS DENIED"); },1000);

  function flashBeepMorphLoop(){
    bigWarning.style.background = next_flash_color();
    wasm_flash_and_beep();

    const x = (Math.random()-0.5)*20;
    const y = (Math.random()-0.5)*20;
    const scale = 1 + (Math.random()-0.5)*0.05;
    bigWarning.style.transform = `translate(${x}px,${y}px) scale(${scale})`;

    setTimeout(flashBeepMorphLoop, Math.random()*200 + 100);
  }
  flashBeepMorphLoop();
}

// Persistent block check
if(is_blocked_forever() || localStorage.getItem("uuidBlockedForever")==="true") selfDestruct();
if(localStorage.getItem("uuidValidated")==="true") loginOverlay.style.display="none";

// ================= WASM UUID Login =================
document.getElementById("loginBtn").onclick = function(){
  const uuid = document.getElementById("uuidInput").value.trim();
  const isValidUUID = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(uuid);
  if(!isValidUUID){ warningMessage.textContent="‚ùå Invalid UUID format!"; return; }

  const isAllowed = validate_uuid(uuid, secretKey, allowedHashes);
  if(!isAllowed){ selfDestruct(); } 
  else { localStorage.setItem("uuidValidated","true"); loginOverlay.style.display="none"; console.log("‚úÖ UUID valid. Access granted."); }
};

// ================= Ultra-Sensitive DevTools + Mobile Trap =================
(function(){
  let devtoolsOpen=false;
  const checkDevTools = () => {
    try { if(wasm_check_devtools()){ selfDestruct(); } } catch(e){ selfDestruct(); }
    const widthDiff = window.outerWidth - window.innerWidth > 160;
    const heightDiff = window.outerHeight - window.innerHeight > 160;
    const start = performance.now(); debugger;
    const debuggerOpen = performance.now() - start > 100;
    if(widthDiff || heightDiff || debuggerOpen){ if(!devtoolsOpen){ devtoolsOpen=true; selfDestruct(); } }
    else devtoolsOpen=false;
  };

  window.addEventListener('keydown', e=>{
    if(e.key==="F12"||(e.ctrlKey && e.shiftKey && ["I","J","C"].includes(e.key))||(e.ctrlKey && e.key==="U")){
      e.preventDefault(); selfDestruct();
    }
  });

  new MutationObserver(()=>selfDestruct()).observe(document.body, {childList:true, subtree:true});
  ['log','error','warn','info','debug','table','dir'].forEach(m=>console[m]=()=>{ selfDestruct(); });

  document.addEventListener('contextmenu', e=>{ e.preventDefault(); selfDestruct(); });
  document.addEventListener('gesturestart', e=>{ selfDestruct(); });
  document.addEventListener('touchstart', e=>{ if(e.touches.length>2) selfDestruct(); });

  let lastWidth = window.innerWidth;
  let lastHeight = window.innerHeight;
  window.addEventListener('resize', ()=>{
    if(Math.abs(window.innerWidth-lastWidth)>50||Math.abs(window.innerHeight-lastHeight)>50) selfDestruct();
    lastWidth = window.innerWidth; lastHeight = window.innerHeight;
  });

  setInterval(()=>{
    const start = performance.now(); debugger;
    if(performance.now()-start>100) selfDestruct();
  },300);

  window.addEventListener('devicemotion', e=>{
    if(e.acceleration&&(Math.abs(e.acceleration.x)>50||Math.abs(e.acceleration.y)>50)) selfDestruct();
  });

  setInterval(checkDevTools,250);
})();
</script>

</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ü™Ñ MTF Crypto ‚Äî Binance Manual Preload + Live WebSocket + Native Buy Alerts (Scored)</title>
  <style>
    :root{
      --bg:#07080a;--panel:#0c0f12;--card:#12161b;--text:#d5f2e3;--muted:#89a39a;--accent:#00ffa3;--warn:#ffd166;--bad:#ff4d4f;--good:#00e676;
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}
    header{padding:14px 16px;border-bottom:1px solid #1b222b;background:linear-gradient(180deg,#0b0e12,transparent)}
    h1{margin:0;font-size:18px;letter-spacing:.5px}
    .wrap{display:grid;grid-template-columns:310px 1fr;gap:14px;padding:14px}
    .card{background:var(--card);border:1px solid #1a222b;border-radius:14px;box-shadow:0 10px 30px rgb(0 0 0 / .25)}
    .panel{padding:14px}
    label{font-size:12px;color:var(--muted)}
    input,select,button{background:#0b1016;color:var(--text);border:1px solid #22303c;border-radius:10px;padding:8px 10px;font-family:inherit}
    button{cursor:pointer}
    button.primary{background:linear-gradient(180deg,#093,#062);border-color:#094;box-shadow:inset 0 0 0 1px #0b6}
    button.red{background:linear-gradient(180deg,#742,#521);border-color:#a42}
    button.ghost{background:transparent}
    .row{display:flex;gap:8px;align-items:center;margin:6px 0}
    .grid{display:grid;gap:8px}
    .grid.cols2{grid-template-columns:1fr 1fr}
    .grid.cols3{grid-template-columns:1fr 1fr 1fr}
    .kps{display:flex;gap:6px;flex-wrap:wrap}
    .badge{padding:2px 8px;border:1px solid #22303c;border-radius:999px;font-size:11px;color:var(--muted)}
    #log{height:220px;overflow:auto;white-space:pre-wrap;background:#0b0f14;border-top:1px dashed #233}
    #output{height:360px;overflow:auto;white-space:pre-wrap}
    .indibox{padding:10px;border-top:1px dashed #22303c;font-size:12px;line-height:1.45}
    .title{color:#a8fbea;font-weight:700}
    .ok{color:var(--good)}.warn{color:var(--warn)}.bad{color:var(--bad)}
    .hl{color:var(--accent)}
    .pill{display:inline-flex;align-items:center;gap:6px;border:1px solid #20313a;border-radius:999px;padding:3px 8px;font-size:12px}
    .muted{color:var(--muted)}
    .switch{display:inline-flex;align-items:center;gap:10px}
    .switch input{accent-color:#0f9}
    .table{font-size:12px;width:100%;border-collapse:collapse}
    .table td,.table th{border-bottom:1px dashed #233;padding:6px 8px;text-align:left}
    .table th{color:#9fd;position:sticky;top:0;background:#0b0f14}
    .small{font-size:11px}
    .foot{padding:10px;color:#7fa;opacity:.7}
    .bar{height:6px;background:#0a1216;border:1px solid #20313a;border-radius:999px;overflow:hidden}
    .bar > i{display:block;height:100%;background:linear-gradient(90deg,#0a4,#0c6);width:0%}
  </style>
</head>
<body>
  <header>
    <h1>üì° MTF Binance ‚Äî Manual Preload / Live WS / Native Buy Alerts (Scored)</h1>
  </header>

  <div class="wrap">
    <!-- LEFT CONTROL PANEL -->
    <section class="card panel" id="controls">
      <div class="grid cols2">
        <div class="grid">
          <label>Symbol (Spot)</label>
          <input id="symbol" value="ETHUSDT" />
        </div>
        <div class="grid">
          <label>Timeframes</label>
          <select id="tfs" multiple size="6">
            <option selected>1m</option>
            <option selected>5m</option>
            <option>15m</option>
            <option>1h</option>
            <option>4h</option>
            <option>1d</option>
          </select>
          <span class="small muted">Hold Ctrl/‚åò to multi‚Äëselect</span>
        </div>
      </div>

      <div class="row">
        <label>Preload (candles / TF)</label>
        <input id="limit" type="number" value="500" min="50" max="1000" step="50" />
        <button class="primary" id="btnPreload">Preload API</button>
      </div>

      <div class="row">
        <button id="btnConnect" class="primary">Connect WebSocket</button>
        <button id="btnDisconnect" class="ghost">Disconnect</button>
        <button id="btnClear" class="ghost">Clear Log</button>
      </div>

      <div class="row switch">
        <input type="checkbox" id="enableAlerts" checked />
        <label for="enableAlerts">Enable Native Alerts (window.alert)</label>
        <button id="btnTest">Test Alert</button>
      </div>

      <div class="grid cols2">
        <div class="grid">
          <label>Score Threshold (0‚Äì100)</label>
          <input id="scoreThresh" type="number" min="0" max="100" value="80" />
        </div>
        <div class="grid">
          <label>Alert Cooldown (sec)</label>
          <input id="cooldown" type="number" min="10" max="600" value="90" />
        </div>
      </div>

      <div class="indibox">
        <div class="title">Buy Rule (Scored v2)</div>
        <div class="small muted">Signal = weighted score aggregated across selected timeframes (heavier on 1m & 5m). Native alert triggers when:</div>
        <ul class="small">
          <li><b>TotalScore ‚â• Threshold</b> (default 80/100) <span class="muted">and</span></li>
          <li>1m &amp; 5m sub‚Äëscores both ‚â• 70, with MACD histogram crossing up &gt; 0</li>
        </ul>
        <div class="small muted">Score uses: EMA vs SMA &amp; VWAP, MACD cross &amp; momentum, RSI zone (50‚Äì70), Stoch K&gt;D from &lt;20, ADX strength, BB location, ATR normalized volatility, Donchian breakout bias, VWAP premium/discount, OBV trend.</div>
      </div>

      <div class="foot small">Tip: Edit <span class="hl">scoreTF()</span> to tweak weights. All math is client‚Äëside, no keys required.</div>
    </section>

    <!-- RIGHT OUTPUT PANEL -->
    <section class="card panel">
      <div class="kps">
        <span class="badge" id="state">Idle</span>
        <span class="badge" id="wsCount">WS: 0</span>
        <span class="badge" id="lastUpd">‚Äî</span>
        <span class="badge" id="totalScore">Score: ‚Äî</span>
      </div>
      <div id="output">Ready ‚Äî preload to compute indicators.
      </div>
      <div id="log" class="panel"></div>
    </section>
  </div>

  <script>
    // ========= Helpers =========
    const $ = (q)=>document.querySelector(q);
    const logBox = $('#log');
    const outBox = $('#output');
    function log(msg){
      const ts = new Date().toLocaleTimeString();
      logBox.textContent = `[${ts}] ${msg}\n` + logBox.textContent;
    }
    function setState(txt){ $('#state').textContent = txt }
    function setWsCount(){ $('#wsCount').textContent = 'WS: '+ Object.keys(sockets).length }
    function setStamp(){ $('#lastUpd').textContent = new Date().toLocaleTimeString() }
    function fmt(n, d=2){ if(n==null||isNaN(n)) return '‚Äî'; return (+n).toFixed(d) }
    const clamp=(n,min,max)=>Math.max(min,Math.min(max,n));

    // ========= Data Stores =========
    const candlesByTf = {}; // { tf: [ {t,o,h,l,c,v} ... ] }
    const lastByTf = {};    // caches of last calc for signals & score
    const sockets = {};     // { tf: WebSocket }

    // ========= Indicator Math =========
    function SMA(period, data){ if(data.length < period) return null; let s=0; for(let i=data.length-period;i<data.length;i++) s+=data[i].c; return s/period }
    function EMA(period, data){ if(data.length<period) return null; const k=2/(period+1); let e=data.slice(0,period).reduce((a,d)=>a+d.c,0)/period; for(let i=period;i<data.length;i++){ e=data[i].c*k+e*(1-k)} return e }
    function EMAArray(period, data){ if(data.length<period) return null; const k=2/(period+1); let arr=[]; let e=data.slice(0,period).reduce((a,d)=>a+d.c,0)/period; arr.push(e); for(let i=period;i<data.length;i++){ e=data[i].c*k+e*(1-k); arr.push(e)} return arr }
    function EMAFromArray(period, arr){ if(!arr||arr.length<period) return null; const k=2/(period+1); let out=[]; let e=arr.slice(0,period).reduce((a,v)=>a+v,0)/period; out.push(e); for(let i=period;i<arr.length;i++){ e=arr[i]*k+e*(1-k); out.push(e)} return out }
    function MACD(data){ const e12=EMAArray(12,data); const e26=EMAArray(26,data); if(!e12||!e26){return [null,null,null]}; const len=Math.min(e12.length,e26.length); const macd=e12.slice(-len).map((v,i)=>v-e26[i]); const sig=EMAFromArray(9,macd); if(!sig) return [null,null,null]; const h=macd[macd.length-1]-sig[sig.length-1]; return [macd.at(-1), sig.at(-1), h] }
    function RSI(period, data){ if(data.length<period+1) return null; let g=0,l=0; for(let i=data.length-period;i<data.length;i++){ const d=data[i].c-data[i-1].c; if(d>=0) g+=d; else l-=d } const ag=g/period, al=l/period; if(al===0) return 100; const rs=ag/al; return 100-100/(1+rs) }
    function BB(period, data){ if(data.length<period) return [null,null,null]; const slice=data.slice(-period); const mean=slice.reduce((a,d)=>a+d.c,0)/period; const v=slice.reduce((a,d)=>a+(d.c-mean)**2,0)/period; const sd=Math.sqrt(v); return [mean, mean+2*sd, mean-2*sd] }
    function ATR(period, data){ if(data.length<period+1) return null; let trs=[]; for(let i=1;i<data.length;i++){ const h=data[i].h, l=data[i].l, pc=data[i-1].c; trs.push(Math.max(h-l, Math.abs(h-pc), Math.abs(l-pc))) } return trs.slice(-period).reduce((a,b)=>a+b,0)/period }
    function Donch(period,data){ if(data.length<period) return [null,null]; const s=data.slice(-period); return [Math.max(...s.map(x=>x.h)), Math.min(...s.map(x=>x.l))] }
    function VWAP(data){ let tpv=0, vol=0; for(const k of data){ const tp=(k.h+k.l+k.c)/3; tpv+=tp*k.v; vol+=k.v } return tpv/vol }
    function OBV(data){ if(data.length<2) return 0; let obv=0; for(let i=1;i<data.length;i++){ if(data[i].c>data[i-1].c) obv+=data[i].v; else if(data[i].c<data[i-1].c) obv-=data[i].v } return obv }
    function Pivots(c){ const p=(c.h+c.l+c.c)/3; const s1=2*p-c.h; const r1=2*p-c.l; return [p,s1,r1] }
    function ParabolicSAR(data, step=0.02, max=0.2){ if(data.length<2) return null; let up=true, sar=data.at(-2).l, ep=data.at(-2).h, af=step; for(let i=data.length-2;i<data.length;i++){ if(up){ sar+=af*(ep-sar); if(data[i].l<sar){ up=false; sar=ep; ep=data[i].l; af=step } else if(data[i].h>ep){ ep=data[i].h; af=Math.min(af+step,max) } } else { sar+=af*(ep-sar); if(data[i].h>sar){ up=true; sar=ep; ep=data[i].h; af=step } else if(data[i].l<ep){ ep=data[i].l; af=Math.min(af+step,max) } } } return sar }
    function ADX(period,data){ if(data.length<period+1) return null; let plus=[],minus=[],trs=[]; for(let i=1;i<data.length;i++){ const up=data[i].h-data[i-1].h; const dn=data[i-1].l-data[i].l; plus.push(up>dn&&up>0?up:0); minus.push(dn>up&&dn>0?dn:0); trs.push(Math.max(data[i].h-data[i].l, Math.abs(data[i].h-data[i-1].c), Math.abs(data[i].l-data[i-1].c))) } const atr=trs.slice(-period).reduce((a,b)=>a+b,0)/period; const p=100*(plus.slice(-period).reduce((a,b)=>a+b,0)/period)/atr; const m=100*(minus.slice(-period).reduce((a,b)=>a+b,0)/period)/atr; const dx=100*Math.abs(p-m)/(p+m); return dx }
    const stochBuf = {}; // {tf: number[]} for %D
    function Stoch(period,data,tf){ if(data.length<period) return [null,null]; const s=data.slice(-period); const H=Math.max(...s.map(d=>d.h)); const L=Math.min(...s.map(d=>d.l)); const C=data.at(-1).c; const K = ((C-L)/(H-L))*100; (stochBuf[tf]??=[]).push(K); if(stochBuf[tf].length>3) stochBuf[tf].shift(); const D = stochBuf[tf].length===3 ? (stochBuf[tf].reduce((a,b)=>a+b,0)/3) : null; return [K,D] }

    // ========= REST (Manual Preload) =========
    async function fetchBinanceKlines(symbol, interval, limit, endTime=null){
      // returns array of {t,o,h,l,c,v}
      const url = new URL('https://api.binance.com/api/v3/klines');
      url.searchParams.set('symbol', symbol.toUpperCase());
      url.searchParams.set('interval', interval);
      url.searchParams.set('limit', Math.min(limit,1000));
      if(endTime) url.searchParams.set('endTime', endTime);
      const res = await fetch(url.toString());
      if(!res.ok) throw new Error('HTTP '+res.status);
      const arr = await res.json();
      return arr.map(k=>({ t:k[0]/1000, o:+k[1], h:+k[2], l:+k[3], c:+k[4], v:+k[5] }));
    }

    async function manualPreload(){
      const symbol = $('#symbol').value.trim().toUpperCase();
      const limit = +$('#limit').value;
      const tfs = [...$('#tfs').selectedOptions].map(o=>o.value);
      setState('Preloading‚Ä¶');
      for(const tf of tfs){
        try{
          const data = await fetchBinanceKlines(symbol, tf, limit);
          candlesByTf[tf] = data;
          log(`‚úÖ Preloaded ${data.length} candles for ${symbol} ${tf}`);
          renderPanel(tf);
        }catch(e){
          log(`‚ùå Preload failed for ${symbol} ${tf}: ${e.message}`);
        }
      }
      updateTotalScore();
      setState('Idle');
    }

    // ========= WebSocket (Manual Start/Stop) =========
    function connectWS(){
      const symbol = $('#symbol').value.trim().toLowerCase();
      const tfs = [...$('#tfs').selectedOptions].map(o=>o.value);
      for(const tf of tfs){
        if(sockets[tf]) continue; // already open
        const url = `wss://stream.binance.com:9443/ws/${symbol}@kline_${tf}`;
        const ws = new WebSocket(url);
        sockets[tf] = ws;
        ws.onopen = ()=>{ log(`üîå WS open: ${symbol} ${tf}`); setWsCount(); setState('Live') };
        ws.onmessage = (ev)=>{
          const msg = JSON.parse(ev.data);
          if(!msg.k) return; // kline payload
          const k = msg.k; // https://binance-docs.github.io/apidocs/spot/en/#kline-candlestick-streams
          const obj = { t:k.t/1000, o:+k.o, h:+k.h, l:+k.l, c:+k.c, v:+k.v };
          const list = candlesByTf[tf] || (candlesByTf[tf]=[]);
          if(!list.length || obj.t > list.at(-1).t){ list.push(obj) } else { list[list.length-1] = obj }
          if(list.length>2000) list.splice(0, list.length-1500); // trim
          renderPanel(tf);
          checkSignals(tf);
          updateTotalScore();
          setStamp();
        };
        ws.onerror = ()=>{ log(`‚ö†Ô∏è WS error: ${symbol} ${tf}`) };
        ws.onclose = ()=>{ log(`üîå WS closed: ${symbol} ${tf}`); delete sockets[tf]; setWsCount(); if(Object.keys(sockets).length===0) setState('Idle') };
      }
    }
    function disconnectWS(){ for(const tf in sockets){ try{ sockets[tf].close() }catch{} delete sockets[tf] } setWsCount(); setState('Idle'); }

    // ========= UI Bindings =========
    $('#btnPreload').onclick = manualPreload;
    $('#btnConnect').onclick = connectWS;
    $('#btnDisconnect').onclick = disconnectWS;
    $('#btnClear').onclick = ()=>{ logBox.textContent = '' };
    $('#btnTest').onclick = ()=>{ if($('#enableAlerts').checked) alert('üîî Test Alert ‚Äî looks good!') };

    // ========= Rendering =========
    function colorize(v, pos=true){ if(v==null||isNaN(v)) return '<span class="muted">‚Äî</span>'; const cls = pos ? (v>0?'ok':(v<0?'bad':'warn')) : (v<0?'ok':(v>0?'bad':'warn')); return `<span class="${cls}">${fmt(v)}</span>` }

    function renderPanel(tf){
      const list = candlesByTf[tf]; if(!list||list.length<35) { outBox.textContent = `‚è≥ Waiting for more candles on ${tf}‚Ä¶`; return }
      const sma14 = SMA(14,list), ema14 = EMA(14,list);
      const [m,s,h] = MACD(list);
      const rsi = RSI(14,list);
      const [mid,bbU,bbL] = BB(20,list);
      const atr = ATR(14,list);
      const [dcH,dcL] = Donch(20,list);
      const vwap = VWAP(list);
      const obv = OBV(list);
      const [p,s1,r1] = Pivots(list.at(-1));
      const sar = ParabolicSAR(list);
      const adx = ADX(14,list);
      const [k,d] = Stoch(14,list,tf);

      const last = list.at(-1);
      const head = `\n== ${$('#symbol').value.toUpperCase()} ${tf} ==  \n`
                  + `O:${fmt(last.o)}  H:${fmt(last.h)}  L:${fmt(last.l)}  C:${fmt(last.c)}  V:${fmt(last.v,0)}\n`;
      const body = `Trend  | SMA14 ${fmt(sma14)}  EMA14 ${fmt(ema14)}  SAR ${fmt(sar)}  ADX ${fmt(adx)}\n`
                 + `MACD   | Line ${fmt(m)}  Sig ${fmt(s)}  Hist ${fmt(h)}\n`
                 + `Mom    | RSI14 ${fmt(rsi)}  StochK ${fmt(k)}  StochD ${fmt(d)}\n`
                 + `Vol    | BB[U ${fmt(bbU)} | L ${fmt(bbL)}]  ATR ${fmt(atr)}  Donch[H ${fmt(dcH)} | L ${fmt(dcL)}]\n`
                 + `Volume | VWAP ${fmt(vwap)}  OBV ${fmt(obv,0)}\n`
                 + `Pivots | P ${fmt(p)}  S1 ${fmt(s1)}  R1 ${fmt(r1)}\n`;

      const existing = document.getElementById('tf-'+tf);
      const scoreObj = scoreTF(tf);
      const html = `<div class="indibox" id="tf-${tf}">
        <div class="title">${$('#symbol').value.toUpperCase()} ‚Ä¢ ${tf} ‚Äî Score: <span class="hl">${fmt(scoreObj.score,0)}</span></div>
        <div class="bar" aria-label="${tf} score bar"><i style="width:${clamp(scoreObj.score,0,100)}%"></i></div>
        <pre>${head+body}</pre>
        <div class="small muted">${scoreObj.explain}</div>
      </div>`;
      if(existing) existing.outerHTML = html; else outBox.insertAdjacentHTML('beforeend', html);

      // save for cross checks & alerts
      lastByTf[tf] = { sma14, ema14, macd:h, macdLine:m, macdSig:s, rsi, k, d, vwap, adx, close:last.c, atr };
    }

    // ========= Scoring =========
    // Returns {score: 0..100, explain: string}
    const prevSig = {}; // {tf: {macdH, kBelow20, kOverD}}

    function scoreTF(tf){
      const L = lastByTf[tf] || computeLite(tf);
      if(!L) return {score:0, explain:`No data for ${tf}`};

      // 1) Trend (EMA>SMA & price>VWAP)
      let trend = 0; if(L.ema14!=null && L.sma14!=null){ trend += (L.ema14>L.sma14?30:0); }
      if(L.close!=null && L.vwap!=null){ trend += (L.close>L.vwap?20:0); }

      // 2) MACD Histogram cross + strength
      const wasH = prevSig[tf]?.macdH ?? -9999; const macdCrossUp = (L.macd!=null && wasH<=0 && L.macd>0);
      let macdW = 0; if(L.macd!=null){ macdW += clamp((L.macd/ (L.close*0.002))*20, -10, 20); } // normalize vs price
      if(macdCrossUp) macdW += 20;

      // 3) RSI sweet spot (50..70, peak 60)
      let rsiW = 0; if(L.rsi!=null){ const dist = Math.abs(L.rsi-60); rsiW = clamp(20 - dist, 0, 20); }

      // 4) Stoch K>D & previously from <20
      const stPrevBelow20 = (prevSig[tf]?.kBelow20 ?? true); const stNow = (L.k!=null && L.d!=null && L.k>L.d);
      let stochW = 0; if(stNow) stochW += 10; if(stPrevBelow20 && stNow) stochW += 10;

      // 5) ADX strength >=20 (scaled to 20pt max)
      let adxW = 0; if(L.adx!=null){ adxW = clamp((L.adx/40)*20, 0, 20); }

      // 6) BB location bias (above mid, not at upper extreme)
      let bbW = 0; const list = candlesByTf[tf]; if(list && list.length>=20){
        const [mid,up,lo] = BB(20,list); if(mid!=null){ if(L.close>mid) bbW+=5; if(L.close<up) bbW+=5; }
      }

      // 7) Donchian bias (towards upper)
      let donW = 0; if(list && list.length>=20){ const [dcH,dcL] = Donch(20,list); if(dcH!=null){ const pos = (L.close-dcL)/Math.max(1e-9,(dcH-dcL)); donW = clamp(pos*10,0,10); } }

      // 8) ATR normalized (prefer moderate volatility) 0..10
      let atrW = 0; if(L.atr!=null && L.close){ const n = (L.atr/L.close); atrW = clamp(10 - Math.abs(n-0.003)/0.003*10, 0, 10); }

      // 9) OBV drift (last 20 steps) 0..5
      let obvW = 0; if(list && list.length>20){ const obNow = OBV(list); const obPrev = OBV(list.slice(0,-20)); obvW = obNow>obPrev?5:0; }

      // update prev trackers for next cross checks
      prevSig[tf] = { macdH: L.macd ?? wasH, kBelow20: (L.k!=null ? L.k<20 : (prevSig[tf]?.kBelow20 ?? true)) };

      const score = clamp(trend + macdW + rsiW + stochW + adxW + bbW + donW + atrW + obvW, 0, 100);
      const explain = `trend:${fmt(trend,0)} macd:${fmt(macdW,0)} rsi:${fmt(rsiW,0)} stoch:${fmt(stochW,0)} adx:${fmt(adxW,0)} bb:${fmt(bbW,0)} don:${fmt(donW,0)} atr:${fmt(atrW,0)} obv:${fmt(obvW,0)}`;
      return { score, explain };
    }

    function computeLite(tf){
      const list = candlesByTf[tf]; if(!list||list.length<35) return null;
      // minimal pack just to allow score before renderPanel() runs
      const sma14 = SMA(14,list), ema14 = EMA(14,list);
      const [m,s,h] = MACD(list);
      const rsi = RSI(14,list);
      const vwap = VWAP(list);
      const adx = ADX(14,list);
      const [k,d] = Stoch(14,list,tf);
      const last = list.at(-1);
      const atr = ATR(14,list);
      return (lastByTf[tf] = { sma14, ema14, macd:h, macdLine:m, macdSig:s, rsi, k, d, vwap, adx, close:last.c, atr });
    }

    function updateTotalScore(){
      const tfs = [...$('#tfs').selectedOptions].map(o=>o.value);
      if(tfs.length===0) { $('#totalScore').textContent = 'Score: ‚Äî'; return }
      const weights = Object.fromEntries(tfs.map(tf=>[tf, tf==='1m'?3: tf==='5m'?2: 1 ]));
      let sum=0, wsum=0; for(const tf of tfs){ const sc = scoreTF(tf).score; const w = weights[tf]||1; if(sc!=null){ sum += sc*w; wsum += w } }
      const total = wsum? (sum/wsum) : 0;
      $('#totalScore').textContent = 'Score: '+fmt(total,0);
      return total;
    }

    // ========= Alerts =========
    const lastAlertAt = {}; // {symbol: epochSec}

    function checkSignals(tf){
      const tfs = [...$('#tfs').selectedOptions].map(o=>o.value);
      const total = updateTotalScore();
      const thresh = +$('#scoreThresh').value;
      const needAlign = ['1m','5m'].filter(x=>tfs.includes(x));

      // per‚ÄëTF guard: 1m & 5m both >=70 + MACD cross condition
      function tfOK(t){ const sc = scoreTF(t); const L = lastByTf[t]; const wasH = prevSig[t]?.macdH ?? -9999; const macdCrossUp = (L && L.macd!=null && wasH<=0 && L.macd>0); return sc.score>=70 && macdCrossUp }
      let aligned = needAlign.length===0 ? true : needAlign.every(tfOK);

      if(total>=thresh && aligned){
        fireBuyAlert(tf, total, needAlign);
      }
    }

    function fireBuyAlert(tf, total, alignedTFs){
      const sym = $('#symbol').value.toUpperCase();
      const price = candlesByTf[tf]?.at(-1)?.c;
      const cooldownSec = +$('#cooldown').value;
      const now = Math.floor(Date.now()/1000);
      const key = sym;
      if(lastAlertAt[key] && (now - lastAlertAt[key]) < cooldownSec){ return } // cooldown
      lastAlertAt[key] = now;

      // Simple risk framework using 1m ATR if available
      const L1m = lastByTf['1m'];
      const atr = L1m?.atr || lastByTf[tf]?.atr || 0;
      const sl = atr ? (price - 1.5*atr) : (price*0.995);
      const tp = atr ? (price + 3*atr) : (price*1.01);

      const msg = `üîî BUY ALERT ${sym} @ ${fmt(price)}\nScore: ${fmt(total,0)} | Align: ${alignedTFs.join(' & ') || '‚Äî'}\nSL: ${fmt(sl)}  TP: ${fmt(tp)} (ATR‚Äëbased)`;
      log(msg);
      if($('#enableAlerts').checked) alert(msg);
    }

    // ======== Boot ========
    log('Ready. 1) Preload via API. 2) Connect WS. 3) Alerts fire when total score ‚â• threshold with 1m/5m alignment.');
  </script>
</body>
</html>
