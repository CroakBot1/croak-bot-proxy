
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>üì° Multi-Pair Crypto Scanner ‚Äî 1m TF</title>
  <style>
    :root{--bg:#000;--card:#0b0b0b;--accent:#0f0;--muted:#666}
    body{background:var(--bg);color:var(--accent);font-family:Inter,Roboto,monospace;margin:0;padding:18px}
    h1{grid-column:span 3;margin:0 0 12px 0}
    .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(320px,1fr));gap:12px}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(15,255,0,0.08);padding:12px;border-radius:8px}
    pre{background:#070707;padding:8px;border-radius:6px;overflow:auto;max-height:220px}
    .title{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
    .big{font-size:20px;font-weight:700}
    .small{font-size:12px;color:var(--muted)}
    .indicator{font-size:13px;line-height:1.4}
    .alert{background:#122f12;color:lime;padding:6px;border-radius:6px;margin-top:8px}
    button{background:transparent;border:1px solid rgba(15,255,0,0.12);color:var(--accent);padding:6px 8px;border-radius:6px;cursor:pointer}
    #controls{display:flex;gap:8px;align-items:center;margin-bottom:12px}
    #log{height:140px;overflow:auto;background:#060606;padding:10px;border-radius:6px;border:1px solid rgba(255,255,255,0.03)}
  </style>
</head>
<body>
  <h1>üì° Multi-Pair Crypto Scanner ‚Äî 1m TF (Bybit) ‚Äî Preload 10k candles / 1k chunks</h1>
  <div id="controls">
    <button id="startBtn">Start Preload & Connect</button>
    <button id="stopBtn">Stop WS</button>
    <div class="small">Audio alerts / Desktop Notifications will be used for alerts</div>
  </div>
  <div class="grid" id="cards"></div>
  <h3 style="margin-top:12px;color:var(--muted)">Console</h3>
  <div id="log"></div>

  <script>
    // --- CONFIG ---
    const SYMBOLS = [
      {id:'ETH', symbol:'ETHUSDT'},
      {id:'BTC', symbol:'BTCUSDT'},
      {id:'SOL', symbol:'SOLUSDT'},
      {id:'XRP', symbol:'XRPUSDT'},
      {id:'BNB', symbol:'BNBUSDT'},
      {id:'LTC', symbol:'LTCUSDT'},
      {id:'DOGE', symbol:'DOGEUSDT'}
    ];
    const INTERVAL = '1'; // 1 minute
    const PRELOAD_TOTAL = 10000; // per symbol
    const CHUNK = 1000; // per request
    const RATE_DELAY = 350; // ms between requests (rate-limit safety)
    const WS_URL = 'wss://stream.bybit.com/v5/public/linear';

    // --- State ---
    const state = {};
    let ws = null;
    const logEl = document.getElementById('log');

    function log(...args){
      const t = new Date().toLocaleTimeString();
      logEl.textContent = `[${t}] ` + args.join(' ') + '\n' + logEl.textContent;
    }

    // --- Create UI cards ---
    const cards = document.getElementById('cards');
    for(const s of SYMBOLS){
      const el = document.createElement('div'); el.className='card';
      el.innerHTML = `
        <div class="title"><div class="big">${s.id} / ${s.symbol}</div><div class="small" id="${s.symbol}-price">--</div></div>
        <div class="indicator" id="${s.symbol}-ind">Loading indicators...</div>
        <pre id="${s.symbol}-candles">Candle buffer: 0</pre>
        <div id="${s.symbol}-alert"></div>
      `;
      cards.appendChild(el);
      state[s.symbol] = {candles:[], lastCandleStart:null, el, alerted:false};
    }

    // --- Indicator functions (shared) ---
    function SMA(period, data){
      if(data.length < period) return null;
      const sum = data.slice(-period).reduce((a,b)=>a + b.close,0);
      return sum/period;
    }
    function EMA(period, data){
      if(data.length < period) return null;
      const k = 2/(period+1);
      let ema = data.slice(0,period).reduce((a,b)=>a + b.close,0)/period;
      for(let i=period;i<data.length;i++){ ema = data[i].close*k + ema*(1-k); }
      return ema;
    }
    function EMAArray(period,data){
      if(data.length < period) return null;
      const k=2/(period+1);
      let res=[]; let ema = data.slice(0,period).reduce((a,b)=>a + b.close,0)/period; res.push(ema);
      for(let i=period;i<data.length;i++){ ema = data[i].close*k + ema*(1-k); res.push(ema); }
      return res;
    }
    function RSI(period,data){
      if(data.length < period+1) return null;
      let gains=0, losses=0;
      for(let i=data.length-period;i<data.length;i++){ const diff = data[i].close - data[i-1].close; if(diff>=0) gains+=diff; else losses -= diff; }
      const avgG = gains/period; const avgL = losses/period; if(avgL===0) return 100; const rs = avgG/avgL; return 100 - 100/(1+rs);
    }
    function MACD(data){
      const e12 = EMAArray(12,data); const e26 = EMAArray(26,data);
      if(!e12||!e26) return [null,null,null];
      const min = Math.min(e12.length,e26.length); const macdLine = e12.slice(-min).map((v,i)=>v - e26.slice(-min)[i]);
      // signal
      const signal = (()=>{ if(macdLine.length < 9) return null; let k = 2/(9+1); let s = macdLine.slice(0,9).reduce((a,b)=>a+b,0)/9; for(let i=9;i<macdLine.length;i++){ s = macdLine[i]*k + s*(1-k);} return s; })();
      const hist = (macdLine.length && signal!==null) ? (macdLine[macdLine.length-1] - signal) : null;
      return [macdLine[macdLine.length-1]||null, signal, hist];
    }
    function Bollinger(period,data){ if(data.length<period) return [null,null]; const slice=data.slice(-period); const mean=slice.reduce((a,b)=>a+b.close,0)/period; const variance=slice.reduce((a,b)=>a+Math.pow(b.close-mean,2),0)/period; const sd=Math.sqrt(variance); return [mean+2*sd, mean-2*sd]; }
    function ATR(period,data){ if(data.length < period+1) return null; const trs=[]; for(let i=1;i<data.length;i++){ const high=data[i].high, low=data[i].low, prev=data[i-1].close; trs.push(Math.max(high-low, Math.abs(high-prev), Math.abs(low-prev))); } return trs.slice(-period).reduce((a,b)=>a+b,0)/period; }
    function Donchian(period,data){ if(data.length<period) return [null,null]; const s=data.slice(-period); return [Math.max(...s.map(x=>x.high)), Math.min(...s.map(x=>x.low))]; }
    function VWAP(data){ if(!data.length) return null; let tpv=0, vol=0; for(const k of data){ const tp = (k.high+k.low+k.close)/3; tpv += tp*k.volume; vol += k.volume; } return tpv/vol; }
    function OBV(data){ if(data.length<2) return 0; let obv=0; for(let i=1;i<data.length;i++){ if(data[i].close>data[i-1].close) obv += data[i].volume; else if(data[i].close<data[i-1].close) obv -= data[i].volume; } return obv; }
    function Stochastic(period,data){ if(data.length < period) return [null,null]; const slice=data.slice(-period); const high=Math.max(...slice.map(d=>d.high)); const low=Math.min(...slice.map(d=>d.low)); const close=data[data.length-1].close; const k = (close-low)/(high-low)*100; return [k, null]; }

    // --- Alert rules (simple combined rule) ---
    // Good long entry when: EMA14 > SMA14 AND MACD histogram > 0 AND RSI between 25-45 AND price near lower Bollinger band or Donchian low
    // Good exit when: MACD histo turns negative OR RSI > 70 OR price hits upper Bollinger band or Donchian high
    function evaluateSignals(sym){
      const st = state[sym]; const d = st.candles; if(d.length < 35) return null;
      const sma14 = SMA(14,d); const ema14 = EMA(14,d); const [macd, signal, hist] = MACD(d); const rsi = RSI(14,d); const [bbU,bbL] = Bollinger(20,d); const [dcH,dcL] = Donchian(20,d);
      const last = d[d.length-1].close;
      const entry = (ema14 && sma14 && ema14 > sma14) && (hist && hist > 0) && (rsi && rsi >= 25 && rsi <=45) && (bbL && last <= bbL*1.005 || (dcL && last <= dcL*1.003));
      const exit = (hist && hist < 0) || (rsi && rsi > 70) || (bbU && last >= bbU*0.997) || (dcH && last >= dcH*0.997);
      return {entry, exit, last, sma14, ema14, hist, rsi, bbU, bbL, dcH, dcL};
    }

    // --- UI update per symbol ---
    function updateUI(sym){
      const st = state[sym]; const elInd = document.getElementById(sym+'-ind'); const pre = document.getElementById(sym+'-candles'); const priceEl = document.getElementById(sym+'-price'); const alertEl = document.getElementById(sym+'-alert');
      const d = st.candles; priceEl.textContent = d.length? d[d.length-1].close : '--';
      pre.textContent = `Candle buffer: ${d.length}`;
      if(d.length<10){ elInd.textContent = '‚è≥ waiting for candles...'; return; }
      const sig = evaluateSignals(sym);
      elInd.innerHTML = `Price: ${sig.last.toFixed(6)}\nEMA14: ${sig.ema14?sig.ema14.toFixed(6):'--'}\nSMA14: ${sig.sma14?sig.sma14.toFixed(6):'--'}\nMACD hist: ${sig.hist?sig.hist.toFixed(6):'--'}\nRSI14: ${sig.rsi?sig.rsi.toFixed(2):'--'}\nBB Upper/Lower: ${sig.bbU?sig.bbU.toFixed(6):'--'} / ${sig.bbL?sig.bbL.toFixed(6):'--'}\nDonchian H/L: ${sig.dcH?sig.dcH.toFixed(6):'--'} / ${sig.dcL?sig.dcL.toFixed(6):'--'}`;
      // Alerts
      if(sig.entry && !st.alerted){
        st.alerted = true;
        showAlert(sym, 'GOOD LONG ENTRY', sig.last);
        alertEl.innerHTML = `<div class="alert">üîî GOOD LONG ENTRY @ ${sig.last.toFixed(6)}</div>`;
      } else if(sig.exit){
        st.alerted = false;
        showAlert(sym, 'GOOD EXIT', sig.last);
        alertEl.innerHTML = `<div class="alert">‚ö†Ô∏è GOOD EXIT @ ${sig.last.toFixed(6)}</div>`;
      }
    }

    // --- Visual + desktop + audio alerts ---
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    function beep(){ try{ const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.connect(g); g.connect(audioCtx.destination); o.type='sine'; o.frequency.value=880; g.gain.value=0.03; o.start(); setTimeout(()=>{ o.stop(); },120); }catch(e){} }
    function showAlert(sym, type, price){
      log(`${sym} ALERT: ${type} @ ${price}`);
      // Desktop notification
      if(Notification.permission === 'granted'){
        const n = new Notification(`${sym} ‚Äî ${type}`, {body:`Price: ${price}`, tag: sym + '-' + type});
      }
      beep();
      // flash card
      const card = state[sym].el; card.style.boxShadow = '0 0 18px rgba(0,255,0,0.12)'; setTimeout(()=>{ card.style.boxShadow='none'; },2200);
    }

    // --- Preload candles per symbol (10000 in 1000 chunks) ---
    async function fetchKlines(symbol, limit=CHUNK, start=null){
      const url = new URL('https://api.bybit.com/v5/market/kline');
      url.searchParams.set('category','linear');
      url.searchParams.set('symbol', symbol);
      url.searchParams.set('interval', INTERVAL);
      url.searchParams.set('limit', limit);
      if(start) url.searchParams.set('start', start);
      const res = await fetch(url.toString());
      return res.json();
    }

    async function preloadForSymbol(symbol){
      const st = state[symbol]; st.candles = [];
      log('Preloading', symbol, `=> ${PRELOAD_TOTAL} candles in ${CHUNK}-chunk`);
      // strategy: request latest by moving start timestamp backward. Bybit v5 expects start in ms; we'll page by oldest timestamp from last batch.
      let fetched = 0;
      // get newest batch first by using no start (Bybit returns latest)
      let cursorStart = null;
      while(fetched < PRELOAD_TOTAL){
        try{
          const json = await fetchKlines(symbol, CHUNK, cursorStart);
          if(json.retCode !== 0 || !json.result?.list?.length) {
            log('No more data or error for', symbol, json.retMsg||json);
            break;
          }
          // json.result.list is array of [ts, open, high, low, close, volume]
          const batch = json.result.list.map(c => ({
            start: Math.floor(c[0]/1000),
            open: Number(c[1]), high: Number(c[2]), low: Number(c[3]), close: Number(c[4]), volume: Number(c[5])
          }));
          // Prepend older -> we want oldest first in candles
          st.candles = [...batch.reverse(), ...st.candles];
          fetched += batch.length;
          log(symbol, 'fetched', fetched);
          // Prepare cursor: use the oldest timestamp of this batch minus 1000ms to fetch earlier data next
          cursorStart = Math.floor(batch[0].start * 1000) - 60000; // bybit start in ms
          await new Promise(r=>setTimeout(r, RATE_DELAY));
        }catch(err){ log('Fetch error', symbol, err.message); break; }
      }
      // trim to latest PRELOAD_TOTAL
      if(st.candles.length > PRELOAD_TOTAL) st.candles = st.candles.slice(-PRELOAD_TOTAL);
      log('Done preload', symbol, 'candles:', st.candles.length);
      // keep only last 2000 for memory safety; indicators use last 150+ but we keep more
      if(st.candles.length > 2000) st.candles = st.candles.slice(-2000);
      updateUI(symbol);
    }

    // --- WebSocket connection for live updates ---
    function connectWS(){
      if(ws) try{ ws.close(); }catch(e){}
      ws = new WebSocket(WS_URL);
      ws.onopen = ()=>{
        log('WS open ‚Äî subscribing to kline.1 for all symbols');
        const args = SYMBOLS.map(s => `kline.1.${s.symbol}`);
        ws.send(JSON.stringify({op:'subscribe', args}));
      };
      ws.onmessage = (ev)=>{
        try{
          const msg = JSON.parse(ev.data);
          if(msg.topic && msg.data){
            const topic = msg.topic; // e.g. kline.1.ETHUSDT
            const parts = topic.split('.');
            const sym = parts[2];
            if(!state[sym]) return;
            const raw = Array.isArray(msg.data)? msg.data[0] : msg.data;
            const k = { start: Number(raw.start), open: Number(raw.open), high: Number(raw.high), low: Number(raw.low), close: Number(raw.close), volume: Number(raw.volume) };
            const st = state[sym];
            const isNew = k.start !== st.lastCandleStart;
            st.lastCandleStart = k.start;
            if(isNew){ st.candles.push(k); if(st.candles.length>2000) st.candles.shift(); }
            else { // live update on last candle
              if(st.candles.length) st.candles[st.candles.length-1] = k; else st.candles.push(k);
            }
            updateUI(sym);
          }
        }catch(e){ console.warn('WS parse error', e); }
      };
      ws.onerror = (e)=>{ log('WS error', e.message || e); };
      ws.onclose = ()=>{ log('WS closed'); };
    }

    // --- Controls ---
    document.getElementById('startBtn').addEventListener('click', async ()=>{
      if(Notification.permission !== 'granted') try{ await Notification.requestPermission(); }catch(e){}
      log('Starting preload for all symbols...');
      // Preload sequentially to be gentle with API
      for(const s of SYMBOLS){ await preloadForSymbol(s.symbol); }
      log('All preloads finished. Connecting websocket...');
      connectWS();
    });
    document.getElementById('stopBtn').addEventListener('click', ()=>{ if(ws) ws.close(); log('WS stop requested'); });

    // --- Periodic UI refresh for indicators (in case we have candles from preload) ---
    setInterval(()=>{
      for(const s of SYMBOLS){ if(state[s.symbol].candles.length) updateUI(s.symbol); }
    }, 1500);

  </script>
</body>
</html>
